var documenterSearchIndex = {"docs":
[{"location":"timeevolution/rotatingframes.html#RotatingFrame","page":"RotatingFrame","title":"RotatingFrame","text":"","category":"section"},{"location":"objects/vibrationalmodes.html#VibrationalMode","page":"VibrationalMode","title":"VibrationalMode","text":"","category":"section"},{"location":"objects/vibrationalmodes.html","page":"VibrationalMode","title":"VibrationalMode","text":"DocsString: VibrationalMode","category":"page"},{"location":"objects/vibrationalmodes.html","page":"VibrationalMode","title":"VibrationalMode","text":"This object is primarily intended to be constructed during the instantiations of an IonTrap.","category":"page"},{"location":"objects/vibrationalmodes.html","page":"VibrationalMode","title":"VibrationalMode","text":"For example, ","category":"page"},{"location":"objects/vibrationalmodes.html","page":"VibrationalMode","title":"VibrationalMode","text":"using IonSim # hide\nc = Ca40()\nchain = LinearChain(\n    ions=[c, c],\n    comfrequencies=(x=3e6,y=3e6,z=1e6), \n    selectedmodes=(;x=[1]) \n)\n\nmode = xmodes(chain)[1]\n\ntypeof(mode) <: VibrationalMode","category":"page"},{"location":"objects/vibrationalmodes.html","page":"VibrationalMode","title":"VibrationalMode","text":"It has the following fields:","category":"page"},{"location":"objects/vibrationalmodes.html","page":"VibrationalMode","title":"VibrationalMode","text":"ν::Real: frequency [Hz]\nmodestructure::Vector{Real}: The normalized eigenvector describing the collective motion        of the ions belonging to this mode.\nδν::Union{Function,Real}: Either a function describing time-dependent fluctuations of ν       or a real number which will be converted to the constant function t -> δν.\nN::Int: Highest level included in the Hilbert space.\naxis::NamedTuple{(:x,:y,:z)}: The axis of symmetry for the vibration. This must lie along       one of the basis vectors x̂, ŷ or ẑ.\nshape::Vector{Int}: Indicates dimension of used Hilbert space (=[N+1]).","category":"page"},{"location":"objects/vibrationalmodes.html","page":"VibrationalMode","title":"VibrationalMode","text":"And can also be utilized to construct quantum states:","category":"page"},{"location":"objects/vibrationalmodes.html","page":"VibrationalMode","title":"VibrationalMode","text":"ψ = c ⊗ mode\nψ.bases","category":"page"},{"location":"objects/vibrationalmodes.html","page":"VibrationalMode","title":"VibrationalMode","text":"ψ.shape","category":"page"},{"location":"objects/vibrationalmodes.html","page":"VibrationalMode","title":"VibrationalMode","text":"typeof(ψ)","category":"page"},{"location":"installation.html#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation.html","page":"Installation","title":"Installation","text":"If you haven't done so already, download Julia (platform specific instructions can be found here). Next, open the Julia app, which should launch a REPL session, and install IonSim using the following commands:","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(\"IonSim\")","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"The main way you'll want to interact with IonSim is inside of a Jupyter notebook. This requires IJulia.jl:","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"Pkg.add(\"IJulia\")","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"And finally, if you'd like to follow along with the example notebooks, you'll need at least PyPlot.jl, an interface to Python's Matplotlib library:","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"Pkg.add(\"PyPlot\")","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"Updating to the latest version of IonSim is easy:","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"Pkg.update(\"IonSim\")","category":"page"},{"location":"objects/linearchains.html#LinearChain","page":"LinearChain","title":"LinearChain","text":"","category":"section"},{"location":"objects/linearchains.html#Theoretical-Background","page":"LinearChain","title":"Theoretical Background","text":"","category":"section"},{"location":"objects/linearchains.html","page":"LinearChain","title":"LinearChain","text":"In some sense a linear chain is the simplest configuration of ions, but it is also the most common. Ions are trapped in effective three-dimensional, harmonic electric potential V:","category":"page"},{"location":"objects/linearchains.html","page":"LinearChain","title":"LinearChain","text":"V propto momega_x^2x^2 + momega_y^2y^2 + momega_z^2z^2","category":"page"},{"location":"objects/linearchains.html","page":"LinearChain","title":"LinearChain","text":"where the magnitude of omega_z is set to be signficantly smaller than omega_x and omega_y. With this choice, if in addition the kinetic energy of the ions is sufficiently small, the ions will crystallize into the shape of a linear chain along the z-direction where the confining force due to the external potential is perfectly balanced by the inter-ion Coulomb repulsion. ","category":"page"},{"location":"objects/linearchains.html","page":"LinearChain","title":"LinearChain","text":"Any residual motion can then be described by small excursions of the ions away from their equilibrium positions where the inter-ion Coulomb repulsion (no longer zero) is well described to first-order. I.e. the Coulomb interaction can be linearized such that the resulting motion is analagous to a linear spring-mass system. ","category":"page"},{"location":"objects/linearchains.html","page":"LinearChain","title":"LinearChain","text":"For example, the motion of the i^th ion in the x-direction is given by:","category":"page"},{"location":"objects/linearchains.html","page":"LinearChain","title":"LinearChain","text":"mddotx_i = -sum_j K_ij x_j","category":"page"},{"location":"objects/linearchains.html","page":"LinearChain","title":"LinearChain","text":"where x_i is the diplacement of the i^th ion from equilibrium and K_ij describes the (first-order) force per unit length that ion i experiences due to a change in position of ion j. By diagonalizing K, we find a collection of normal modes beta^k and associated eigenfrequencies nu_k such that a general solution for x is given by:","category":"page"},{"location":"objects/linearchains.html","page":"LinearChain","title":"LinearChain","text":"x_i(t) = sum_k c_k beta^k_i e^inu_k t","category":"page"},{"location":"objects/linearchains.html","page":"LinearChain","title":"LinearChain","text":"But in this regime, the kinetic energy of the ions is comparable to the ground state energy so the description must be quantized. It turns out, this can be done by associating a quantum harmonic oscillator with each normal mode beta^k, such that the displacement of ion i from equilibrium is given by:","category":"page"},{"location":"objects/linearchains.html","page":"LinearChain","title":"LinearChain","text":"hatx_i = sum_k c_k beta_i^k sqrtfrachbar2mnu_k(hata_k^dagger + hata_k) ","category":"page"},{"location":"objects/linearchains.html","page":"LinearChain","title":"LinearChain","text":"where hata^dagger_k and  hata_k satisfy the normal commutation relation hata_k hata^dagger_k =1. Given a collection of ions defined by their mass and charge, IonSim will solve for these normal modes of motion and their associated vibrational frequencies. ","category":"page"},{"location":"objects/linearchains.html","page":"LinearChain","title":"LinearChain","text":"note: Note\nIn the above, we've implicitly assumed that the ions were identical in mass and charge. The situation is a bit more complicated when this is no longer true, but IonSim can handle these situations as well.","category":"page"},{"location":"objects/linearchains.html#Purpose","page":"LinearChain","title":"Purpose","text":"","category":"section"},{"location":"objects/linearchains.html","page":"LinearChain","title":"LinearChain","text":"DocString: LinearChain","category":"page"},{"location":"objects/linearchains.html","page":"LinearChain","title":"LinearChain","text":"The main purpose of a LinearChain object is to organize and store information about the coupled center of mass motion for a chain of ions, which can then be used to construct a Chamber as a next step towards simulating a trapped ion experiment. Assuming a harmonic potential confining potential and a linearized, inter-ion Coulomb interaction as described earlier, the structure of this motion is uniquely specified given three frequencies. ","category":"page"},{"location":"objects/linearchains.html#Buiding-a-LinearChain","page":"LinearChain","title":"Buiding a LinearChain","text":"","category":"section"},{"location":"objects/linearchains.html","page":"LinearChain","title":"LinearChain","text":"Creating an instance of LinearChain requires three arguments:","category":"page"},{"location":"objects/linearchains.html","page":"LinearChain","title":"LinearChain","text":"ions: An iterable collection of ions<:Ion.\ncomfrequencies: A NamedTuple{:x, :y, :z} specifying the vibrational frequencies for the center of mass modes, e.g. comfrequencies = (x=3e6, y=3e6, z=1e6).\nselectedmodes: Another NamedTuple{:x, :y, :z} but with arguments that are lists of integers e.g. selectedmodes = (x=[1, 3], y=[:], z=[1:3, 5]). These specify a subset of the normal modes that will actually be taken into account during simulation.","category":"page"},{"location":"objects/linearchains.html","page":"LinearChain","title":"LinearChain","text":"An optional keyword argument N::Int can be specified, which sets the Hilbert space dimension assoicated with each generated normal mode (this defaults to 10).","category":"page"},{"location":"objects/linearchains.html","page":"LinearChain","title":"LinearChain","text":"note: Note\nIn the case that all ions have the same mass and charge, the COM motion of the ion chain factors into three unique modes (one for each spatial coordinate). And these are typically used to characterize the normal mode structure of the chain since they are the same independent of the number of ions. However, When the ions are not identical, this is no longer true. In this case, comfrequencies corresponds to the lowest (highest) frequency normal mode in the axial (radial) directions, in correspondence with the homogeneous case.","category":"page"},{"location":"objects/linearchains.html","page":"LinearChain","title":"LinearChain","text":"For example:","category":"page"},{"location":"objects/linearchains.html","page":"LinearChain","title":"LinearChain","text":"using IonSim # hide\nc = Ca40()\nb = Be9()\nchain = LinearChain(\n    ions=[c, c, b, b],\n    comfrequencies=(x=7e6,y=7e6,z=1e6), \n    selectedmodes=(x=[:], y=[1:3], z=[1, 2])  # Note: selectedmodes now supports slicing\n)","category":"page"},{"location":"objects/linearchains.html","page":"LinearChain","title":"LinearChain","text":"Creates a 4-ion chain of two calcium ions and 2 beryllium ions where the smallest normal mode axial frequency is 1 MHz and the largest frequency in both of the radial directions is 7 MHz. chain has four fields (which you can see by typing a period and hitting the tab key).","category":"page"},{"location":"objects/linearchains.html","page":"LinearChain","title":"LinearChain","text":"(Image: )","category":"page"},{"location":"objects/linearchains.html","page":"LinearChain","title":"LinearChain","text":"chain.comfrequencies and chain.ions correspond to the arguments used to instantiate chain. chain.ionpositions is a vector of floats representing the positions of the ions in the chain in meters:","category":"page"},{"location":"objects/linearchains.html","page":"LinearChain","title":"LinearChain","text":"ionpositions(chain) .* 1e6","category":"page"},{"location":"objects/linearchains.html","page":"LinearChain","title":"LinearChain","text":"chain.selectedmodes now contains a NamedTuple of VibrationalModes:","category":"page"},{"location":"objects/linearchains.html","page":"LinearChain","title":"LinearChain","text":"selectedmodes(chain).x","category":"page"},{"location":"objects/linearchains.html","page":"LinearChain","title":"LinearChain","text":"which are quantum operators further described in the VibrationalMode section.","category":"page"},{"location":"objects/linearchains.html","page":"LinearChain","title":"LinearChain","text":"typeof(selectedmodes(chain).x[1]) <: IonSimBasis","category":"page"},{"location":"objects/linearchains.html","page":"LinearChain","title":"LinearChain","text":"The normal mode structure can be better understood by using IonSim's visualize function:","category":"page"},{"location":"objects/linearchains.html","page":"LinearChain","title":"LinearChain","text":"using Plots\nvisualize(chain, ẑ, [:])","category":"page"},{"location":"objects/linearchains.html","page":"LinearChain","title":"LinearChain","text":"visualize(chain, x̂, [:], format=\"circles\")","category":"page"},{"location":"objects/linearchains.html#Buiding-from-YAML","page":"LinearChain","title":"Buiding from YAML","text":"","category":"section"},{"location":"objects/linearchains.html","page":"LinearChain","title":"LinearChain","text":"One can alternatively build a LinearChain from a yaml file. If the file normal_mode.yaml has the following contents:","category":"page"},{"location":"objects/linearchains.html","page":"LinearChain","title":"LinearChain","text":"---\nx:\n  - frequency: 1e6\n    mode: [0.1, 0.5, 0.3, 0.8]\n  - frequency: 2e6\n    mode: [0.3, 0.6, 0.5, 3]\ny:\n  - frequency: 8e6\n    mode: [1, 1, 1, 1]\nionpositions: [1,2,3,4]","category":"page"},{"location":"objects/linearchains.html","page":"LinearChain","title":"LinearChain","text":"Then this can be used to instantiate a LinearChain using:","category":"page"},{"location":"objects/linearchains.html","page":"LinearChain","title":"LinearChain","text":"chain = LinearChain_fromyaml(\n    ions=[c, c, c, c],\n    yaml=\"normal_mode.yaml\",  \n)","category":"page"},{"location":"objects/linearchains.html#Additional-Functionality","page":"LinearChain","title":"Additional Functionality","text":"","category":"section"},{"location":"objects/linearchains.html","page":"LinearChain","title":"LinearChain","text":"A normal mode calculation can be performed without the need for a LinearChain using full_normal_mode_description.","category":"page"},{"location":"objects/linearchains.html","page":"LinearChain","title":"LinearChain","text":"mass_list =    [1, 1, 1, 1, 1]\ncharge_list =  [2, 1, 2, 2, 1]\nfnm = full_normal_mode_description(mass_list, charge_list, (x=5e6, y=5e6, z=1e6))\nfnm.x","category":"page"},{"location":"objects/linearchains.html","page":"LinearChain","title":"LinearChain","text":"visualize(fnm.x[2], ẑ, format=\"circles\")","category":"page"},{"location":"objects/linearchains.html","page":"LinearChain","title":"LinearChain","text":"<!– @example lc1 x = range(0, 10, length=100) y = sin.(x) plot(x, y) –>","category":"page"},{"location":"timeevolution/technicalnoise.html#Technical-Noise","page":"Technical Noise","title":"Technical Noise","text":"","category":"section"},{"location":"api.html#API","page":"API","title":"API","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"DocTestSetup  = quote\n    using IonSim\nend","category":"page"},{"location":"api.html","page":"API","title":"API","text":"Modules = [IonSim, IonSim.analytical, IonSim.PhysicalConstants]\nPrivate = false\nPublic = true","category":"page"},{"location":"api.html#IonSim.Chamber","page":"API","title":"IonSim.Chamber","text":"Chamber(;\n        iontrap::LinearChain, B::Real=0, Bhat::NamedTuple{(:x,:y,:z)=ẑ, ∇B::Real=0,\n         δB::Union{Real,Function}=0, lasers::Vector{Laser}\n)\n\nInformation necessary to describe the Hamiltonian for a collection of ions in a linear chain interacting with laser light. user-defined fields\n\niontrap<:LinearChain\nB: A real value describing the mean magnitude of the B-field [Tesla].\nBhat::NamedTuple{(:x,:y,:z)}: Describes the direction of the B-field (defaults to ẑ).\n∇B: Magnitude of the B-field gradient. We assume that the gradient always points along the       z-direction. [Tesla / meter]\nδB::Function: Time-dependence of the B-field [Tesla]\nlasers::Array{<:Laser}: For each laser in the array, the pointing field should contain       an array of Tuple{Int,Real}. The first element specifies the index of an ion       in the ions field that the laser interacts with. The second element specifies a       scaling factor for the strength of that interaction (to be used, e.g., for       modeling cross-talk).\n\nderived fields\n\n_cnst_δB::Bool: A Boolean flag signifying whether or not δB is a constant function.\nbasis<:CompositeBasis: The basis for describing the combined system, ions + vibrational       modes. If constructing the Hamiltonian explictly (with hamiltonian), then       the ordering of the basis is set, by convention, as       ion₁  ion₂    ion_N  mode₁  mode₂    mode_N, where the ion bases are       ordered according to the order in T.iontrap.ions and the vibrational modes       are ordered according to the order in       [T.iontrap.selectedmodes.x, T.iontrap.selectedmodes.y,       T.iontrap.selectedmodes.z].   E.g. for:\nchain = LinearChain(ions=[C1, C2], comfrequencies=(x=2e6,y=2e6,z=1e6),   selectedmodes=(x=[1, 2], y=[], z=[1]))\nThe ordering of the basis would be\nC1.basis ⊗ C2.basis ⊗ chain.selectedmodes.x[1].basis   ⊗ chain.selectedmodes.x[2].basis ⊗ chain.selectedmodes.z[1].basis\nOtherwise, the ordering is according to the form of the initial state used in the solver.\n\n\n\n\n\n","category":"type"},{"location":"api.html#IonSim.Ion","page":"API","title":"IonSim.Ion","text":"Ion\n\nThe physical parameters defining an isolated ion's internal structure.\n\n\n\n\n\n","category":"type"},{"location":"api.html#IonSim.IonInstance","page":"API","title":"IonSim.IonInstance","text":"IonInstance(selected_sublevels::Vector{Tuple}[, manualshift::Dict]) Ion instance of some species\n\nselected_sublevels specifies which energy sublevels will be present in the Hilbert space of  this Ion instance, as a subset of all possible sublevels.\n\nEach element of selected_sublevels is a 2-element Tuple (level::String, sublevels), with the first element being the name of a level and the second specifying which sublevels should be included. Allowed sublevels are those whose magnetic quantum number m is in the set {-f, -f+1, -f+2, ... f-1, f}, where f is the total angular momentum quantum number of level. For each level specified there are three allowed options to specify the set of sublevels to include:\n\nsublevels::Real: Includes only one m = sublevels\nsublevels::Vector{Real}: Includes all sublevels whose magnetic quantum number m is in sublevels\nsublevels = \"all\": Includes all allowed sublevels\n\nIf an element of selected_sublevels utilizes the first option, specifying a single m, one may optionally may this a 3-element tuple instead: (level::String, m::Real, alias::String), assinging this particular sublevel the alias alias.\n\nOmission of a level in selected_sublevels will exclude all sublevels.\n\nFields\n\nspeciesproperties::IonProperties: Contains constants specifying parameters specific to species\nsublevels::Vector{Tuple{String,Real}}: List of all sublevels present in the Hilbert space\nsublevelaliases::Dict{String,Tuple}: Dict specifying aliases assigned to sublevels, in the format alias => sublevel\nshape::Vector{Int}: Dimension of the Hilbert space\nmanualshift::OrderedDict: A dictionary with keys denoting the selected levels and values, a real number for describing a shift of the level's energy. This is just a convenient way to add manual shifts to the simulation, such as Stark shifts off of energy levels not present in the Hilbert space, without additional resources\nionnumber: When the ion is added to an IonTrap, this value keeps track of its order\nionposition: When the ion is added to an IonTrap, this value keeps track of its physical position in meters\n\n\n\n\n\n","category":"type"},{"location":"api.html#IonSim.IonProperties","page":"API","title":"IonSim.IonProperties","text":"IonProperties type.\n\nRequired keywords\n\nmass: Mass of ion in kg\ncharge: Charge of ion in units of elementary charge\nfull_level_structure: OrderedDict describing properties of each energy level\nkey::String: Name of energy level. Spectroscopic notation encouraged, e.g. \"S1/2,f=1\"\nvalue::NamedTuple(:n, :l, :j, :f, :E): Quantum numbers n, l, j, f, and energy  E (in Hz)\nfull_transitions: Dict of all allowed transitions between energy levels\nkey::Tuple{String,String} Pair of levels, ordered (lower, upper) in energy\nvalue::NamedTuple(:multipole, :einsteinA): Leading-order multipole of the transition   (e.g. \"E1\", \"E2\") and Einstein A coefficient (between fine structure levels only;   hyperfine factors are calculated when needed)\n\nOptional keywords\n\ndefault_sublevel_selection: Default value of selected_sublevels argument in Ion   constructor\ngfactors: Dict(level::String => g::Real) Custom Landé g-factors, if contributions from   higher-than-first-order perturbations are desired\nnonlinear_zeeman: Dict describing nonlinear contributions to Zeeman shift of certain   sublevels\nkey::Tuple{String,Real}: sublevel name\nvalue::Function(B::Real): Nonlinear term(s) of Zeeman shift. Full Zeeman shift will be   calculated as the sum of the usual linear term and this function\n\n\n\n\n\n","category":"type"},{"location":"api.html#IonSim.IonSimBasis","page":"API","title":"IonSim.IonSimBasis","text":"IonSimBasis\n\nAn abstract type for specialized bases, which are unique to IonSim.\n\n\n\n\n\n","category":"type"},{"location":"api.html#IonSim.IonTrap","page":"API","title":"IonSim.IonTrap","text":"IonTrap\n\nA physical configuration of ions. Stores a collection of ions and information about their relative center of mass motion.\n\n\n\n\n\n","category":"type"},{"location":"api.html#IonSim.Laser","page":"API","title":"IonSim.Laser","text":"Laser(;λ=missing, E=0, Δ=0, ϵ=(x̂+ŷ)/√2, k=ẑ, ϕ=0, pointing::Array{Tuple{Int,Real}})\n\nThe physical parameters defining laser light. args\n\nλ::Union{Real,Missing}: the wavelength of the laser in meters\nI::Union{Function,Real}: laser intensity in W/m²\nΔ: static detuning from f = c/λ in [Hz]\nϵ::NamedTuple: (ϵ.x, ϵ.y, ϵ.z), polarization direction, requires norm of 1\nk::NamedTuple: (k.x, k.y, k.z), propagation direction, requires norm of 1\nϕ::Union{Function,Real}: time-dependent phase. of course, this can also be used to model a    time-dependent detuning. Units are in radians. Note: if this is set to a function of time,   then when constructing a Hamiltonian with the hamiltonian function, the units of time   will be as specified by the timescale keyword argument.\npointing: an array of Tuple{Int,Real} for describing ion-laser pointing configuration.   (first element of the tuple is the index for an ion and the second element is the scaling   factor for the laser's Efield which must be between 0 and 1).\n\n\n\n\n\n","category":"type"},{"location":"api.html#IonSim.LinearChain","page":"API","title":"IonSim.LinearChain","text":"LinearChain(;\n        ions, comfrequencies::NamedTuple{(:x,:y,:z)},\n        selectedmodes::NamedTuple{(:x,:y,:z), N::Int=10\n    )\n\nGenerates and stores all of the information necessary to describe a collection of ions trapped  in a 3D harmonic potential and forming a linear coulomb crystal. Relevant to calculating the normal mode structure of the linear chain is the charge, mass  and ordering of the ions.\n\nuser-defined fields\n\nions: An iterable list of ions that compose the linear Coulomb crystal\ncomfrequencies::NamedTuple{(:x,:y,:z): Describes the COM frequencies    (x=ν_x, y=ν_y, z=ν_z). The z-axis is taken to be along the crystal's axis of    symmetry. Note that these only correspond to true COM modes if all ions have the same   mass, otherwise this is a misnomer and corresponds to the smallest (largest) eigenfrequency   mode in the axial (radial) directions. Note: we assume that ν_x > ν_y > ν_z.\nselectedmodes::NamedTuple{(:x,:y,:z)}:  e.g. selectedmodes=(x=[1], y=[1, 2:3], z=[:]).   Specifies the axis and a list of integers which correspond to the i^th farthest   mode away from the COM (see note above about meaning of \"COM\") for that axis. For example,    selectedmodes=(z=[2]) would specify the axial stretch mode. These are the modes that will    be modeled in the chain.Note: selectedmodes=(x=[],y=[],z=[1]), selectedmodes=(y=[],z=[1])   and selectedmodes=(;z=[1]) are all acceptable and equivalent.\nN::Int=10: Optionally specify the Hilbert space dimension for each normal mode.\n\nderived fields\n\nionpositions::Vector{<:Real}: The relative positions of the ions in meters.  \n\n\n\n\n\n","category":"type"},{"location":"api.html#IonSim.VibrationalMode","page":"API","title":"IonSim.VibrationalMode","text":"VibrationalMode(\n        ν::Real, modestructure::Vector{Real}, δν::Union{Function,Real}=0.; N::Int=10,\n        axis::NamedTuple{(:x,:y,:z)}=ẑ\n    )\n\nuser-defined fields\n\nν::Real: frequency [Hz]\nmodestructure::Vector{Real}: The normalized eigenvector describing the collective motion        of the ions belonging to this mode.\nδν::Union{Function,Real}: Either a function describing time-dependent fluctuations of ν       or a real number which will be converted to the constant function t -> δν.\nN::Int: Highest level included in the Hilbert space.\naxis::NamedTuple{(:x,:y,:z)}: The axis of symmetry for the vibration. This must lie along       one of the basis vectors x̂, ŷ or ẑ.\n\nderived fields\n\nshape::Vector{Int}: Indicates dimension of used Hilbert space (=[N+1]).\n_cnst_δν::Bool: A Boolean flag signifying whether or not δν is a constant function.\n\nNote: the iᵗʰ Fock state (|i⟩) can be obtained by indexing as v=VibrationalMode(...); v[i]\n\n\n\n\n\n","category":"type"},{"location":"api.html#IonSim.LinearChain_fromyaml-Tuple{}","page":"API","title":"IonSim.LinearChain_fromyaml","text":"LinearChain_fromyaml(ions::Vector{<:Ion}, yaml::String; N::Int=10)\n\nLoad normal mode structure from the specified yaml file. It's up to the user to enforce physicality.\n\nx:\n  - frequency: 1e6\n    mode: [0.1, 0.5, 0.3, 0.8]\n  - frequency: 2e6\n    mode: [0.3, 0.6, 0.5, 3]\ny:\n  - frequency: 8e6\n    mode: [1, 1, 1, 1]\nionpositions: [-1, -0.5, -0.25, 5]\n\nIt is up to the user to enforce the physicality of this structure.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.axis-Tuple{VibrationalMode}","page":"API","title":"IonSim.axis","text":"axis(mode::VibrationalMode)\n\nReturns mode.axis\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.basis-Tuple{Chamber}","page":"API","title":"IonSim.basis","text":"basis(chamber::Chamber)\n\nReturns the composite basis describing the Hilbert space for chamber. This is the same as basis(iontrap(chain)).\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.basis-Tuple{LinearChain}","page":"API","title":"IonSim.basis","text":"basis(chain::LinearChain)::CompositeBasis\n\nReturns the composite basis describing the Hilbert space for chain.\n\nOrder is ion₁  ion₂    ion_N  mode₁  mode₂    mode_N, where the ion bases are ordered according to the order in ions(chain) and the vibrational modes are ordered according to the order in [xmodes(chain), ymodes(chain), zmodes(chain)].\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.bfield!-Tuple{Chamber, Real}","page":"API","title":"IonSim.bfield!","text":"bfield!(chamber::Chamber, B::Real)\n\nSets chamber.B to B\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.bfield-Tuple{Chamber, Ion}","page":"API","title":"IonSim.bfield","text":"bfield(chamber::Chamber, ion)\n\nRetuns the value of the magnetic field in T at the location of ion, including both the trap's overall B-field and its B-field gradient. ion may be either an Ion or an Int indicating the desired ion's index within chamber.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.bfield-Tuple{Chamber}","page":"API","title":"IonSim.bfield","text":"bfield(chamber::Chamber)\n\nReturns the magnitude of the (average) magnetic field in chamber, chamber.B,in T.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.bfield_fluctuation!-Tuple{Chamber, Function}","page":"API","title":"IonSim.bfield_fluctuation!","text":"bfield_fluctuation!(chamber::Chamber, δB::Function)\n\nSets chamber.δB to δB\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.bfield_fluctuation!-Tuple{Chamber, Real}","page":"API","title":"IonSim.bfield_fluctuation!","text":"bfield_fluctuation!(chamber::Chamber, δB::Real)\n\nSets chamber.δB to a constant function t -> δB\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.bfield_fluctuation-Tuple{Chamber}","page":"API","title":"IonSim.bfield_fluctuation","text":"bfield_fluctuation(chamber::Chamber)::Function\n\nReturns the small magnetic field fluctuation chamber.δB in T as a function of time in s.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.bfield_unitvector!-Tuple{Chamber, NamedTuple{(:x, :y, :z), T} where T<:Tuple}","page":"API","title":"IonSim.bfield_unitvector!","text":"bfield_unitvector!(chamber::Chamber, Bhat::NamedTuple)\n\nSets chamber.Bhat to Bhat\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.bfield_unitvector-Tuple{Chamber}","page":"API","title":"IonSim.bfield_unitvector","text":"bfield_unitvector(chamber::Chamber)::NamedTuple{:x, :y, :z}\n\nReturns the direction of the magnetic field inside chamber, chamber.Bhat\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.bgradient!-Tuple{Chamber, Real}","page":"API","title":"IonSim.bgradient!","text":"bgradient!(chamber::Chamber, ∇B::Real)\n\nSets chamber.∇B to ∇B\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.bgradient!-Tuple{Chamber, Tuple{Int64, Int64}, Tuple, Real}","page":"API","title":"IonSim.bgradient!","text":"bgradient!(\n        T::Chamber, ion_indxs::Tuple{Int,Int}, transition::Tuple, d::Real\n    )\n\nSets the Bfield gradient in place to achieve a detuning d between the transition of two ions, which are assumed to be of the same species. ion_indxs refer to the ordering of the ions in the chain.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.bgradient-Tuple{Chamber}","page":"API","title":"IonSim.bgradient","text":"bgradient(chamber::Chamber)\n\nReturns the gradient of the magnetic field inside chamber, chamber.∇B, in T/m.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.charge-Tuple{Ion}","page":"API","title":"IonSim.charge","text":"charge(ion::Ion)\n\nReturns the charge of ionin C.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.clearsublevelalias!-Tuple{Ion, Tuple{String, Real}}","page":"API","title":"IonSim.clearsublevelalias!","text":"clearsublevelalias!(I::Ion, sublevel)\n\nErases the assignment of an alias to sublevel of Ion I. Accepts either the full sublevel Tuple{String,Real} or its alias String. Also accepts a vector of sublevels to clear multiple alias assignments in a single call.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.clearsublevelalias!-Tuple{Ion}","page":"API","title":"IonSim.clearsublevelalias!","text":"clearsublevelalias!(I::Ion)\n\nErases the assignment of all sublevel aliases of Ion I. \n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.coherentstate-Tuple{VibrationalMode, Number}","page":"API","title":"IonSim.coherentstate","text":"coherentstate(v::VibrationalMode, α::Number)\n\nReturns a coherent state on v with complex amplitude α.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.comfrequencies-Tuple{LinearChain}","page":"API","title":"IonSim.comfrequencies","text":"comfrequencies(chain::LinearChain)\n\nReturns chain.comfrequencies\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.create-Tuple{VibrationalMode}","page":"API","title":"IonSim.create","text":"create(v::VibrationalMode)\n\nreturns the creation operator for v such that: create(v) * v[i] = √(i+1) * v[i+1].\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.destroy-Tuple{VibrationalMode}","page":"API","title":"IonSim.destroy","text":"destroy(v::VibrationalMode)\n\nReturns the destruction operator for v such that: destroy(v) * v[i] = √i * v[i-1].\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.detuning!-Tuple{Laser, Real}","page":"API","title":"IonSim.detuning!","text":"wavelength!(laser::Laser, Δ::Real)\n\nSets the detuning of laser to Δ.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.detuning-Tuple{Laser}","page":"API","title":"IonSim.detuning","text":"detuning(laser::Laser)::Real\n\nReturns the laser's detuning laser.Δ (in Hz)\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.efield-Tuple{Laser}","page":"API","title":"IonSim.efield","text":"efield(laser::Laser)::Function\n\nReturns the electric field amplitude (in V/m) of laser as a function of time.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.efield-Tuple{Real}","page":"API","title":"IonSim.efield","text":"efield(I::Real)::Real\n\nReturns the electric field (in V/m) corresponding to a light intensity of I (in W/m²) E = √(2I/(cϵ₀))\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.einsteinA-Tuple{Ion, Tuple{String, String}}","page":"API","title":"IonSim.einsteinA","text":"einsteinA(I::Ion, leveltransition::Tuple)\n\nReturns Einstein A coefficient corresponding to the transition leveltransition[1] -> leveltransition[2]. The first level must be the lower level and the second must be the upper level.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.energy-Tuple{Ion, String}","page":"API","title":"IonSim.energy","text":"energy(I::Ion, level::String)\n\nReturns the energy of level of I.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.energy-Tuple{Ion, Tuple{String, Real}}","page":"API","title":"IonSim.energy","text":"energy(I::Ion, sublevel; B=0, ignore_manualshift=false)\n\nReturns energy of sublevel of I. A Zeeman shift may be included by setting the value of the magnetic field B. The manual shift may be omitted by setting ignore_manualshift=true.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.frequency!-Tuple{VibrationalMode, Real}","page":"API","title":"IonSim.frequency!","text":"frequency!(mode::VibrationalMode, ν::Real)\n\nSets mode.ν to ν\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.frequency-Tuple{VibrationalMode}","page":"API","title":"IonSim.frequency","text":"frequency(mode::VibrationalMode)\n\nReturns mode.ν\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.frequency_fluctuation!-Tuple{VibrationalMode, Function}","page":"API","title":"IonSim.frequency_fluctuation!","text":"frequency_fluctuation!(mode::VibrationalMode, δν::Function)\n\nSets mode.δν to δν\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.frequency_fluctuation!-Tuple{VibrationalMode, Real}","page":"API","title":"IonSim.frequency_fluctuation!","text":"frequency_fluctuation!(mode::VibrationalMode, δν::Real)\n\nSets mode.δν to a constant function t -> δν\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.frequency_fluctuation-Tuple{VibrationalMode}","page":"API","title":"IonSim.frequency_fluctuation","text":"frequency_fluctuation(mode::VibrationalMode)\n\nReturns mode.δν\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.full_normal_mode_description-Tuple{Any, NamedTuple{(:x, :y, :z), T} where T<:Tuple}","page":"API","title":"IonSim.full_normal_mode_description","text":"full_normal_mode_description(ions, comfreqs::NamedTuple{(:x, :y, :z)})\n\nSame thing but with an iterable list of ions and NamedTuple of COM frequencies explicitly given.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.full_normal_mode_description-Tuple{LinearChain}","page":"API","title":"IonSim.full_normal_mode_description","text":"full_normal_mode_description(chain::LinearChain)\n\nFor each axis, this contains an array of tuples where the first element is a vibrational frequency [Hz] and the second element is a vector describing the participation of each ion at that vibrational frequency (i.e. the normal mode eigenvector corresponding to that  eigenfrequency).\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.full_normal_mode_description-Tuple{Vector{var\"#s139\"} where var\"#s139\"<:Real, Vector{var\"#s138\"} where var\"#s138\"<:Int64, NamedTuple{(:x, :y, :z), T} where T<:Tuple}","page":"API","title":"IonSim.full_normal_mode_description","text":"function full_normal_mode_description(\n    M::Vector{<:Real}, Q::Vector{<:Int}, comfreqs::NamedTuple{(:x, :y, :z)}\n)\n\nSame thing but explicitly provide the masses M and charges Q of the ions.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.globalbeam!-Tuple{Laser, Chamber}","page":"API","title":"IonSim.globalbeam!","text":"globalbeam!(laser, chamber::Chamber)\n\nSet laser to shine with full intensity on all ions in Chamber. laser may be either a Laser or an Int indicating the desired laser's index within chamber.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.groundstate-Tuple{VibrationalMode}","page":"API","title":"IonSim.groundstate","text":"groundstate(obj)\n\nIf obj is a VibrationalMode, returns the N=0 ket of that mode. If obj is a Vector of VibrationalMode, returns a tensor product mode1[0] ⊗ mode2[0] ⊗ ... in the same order given. If obj is a LinearChain, returns the full ground state of the motional degrees of freedom as a tensor product.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.hamiltonian-Tuple{Chamber}","page":"API","title":"IonSim.hamiltonian","text":"hamiltonian(\n        chamber::Chamber; timescale::Real=1, lamb_dicke_order::Union{Vector{Int},Int}=1,\n        rwa_cutoff::Real=Inf, displacement=\"truncated\", time_dependent_eta=false\n    )\n\nConstructs the Hamiltonian for chamber as a function of time. Return type is a function h(t::Real, ψ) that, itself, returns a QuantumOptics.SparseOperator.\n\nargs\n\ntimescale: e.g. a value of 1e-6 will take time to be in μs\nlamb_dicke_order: Only consider terms that change the phonon number by up to this value.   If this is an Int, then the cutoff is applied to all modes. If this is a Vector{Int},   then lamb_dicke_order[i] is applied to the iᵗʰ mode, according to the order in   basis(chamber).   Note: this isn't quite the same thing as the Lamb-Dicke approximation since setting   lamb_dicke_order=1 will retain, for example, terms proportional to a^dagger a.\nrwa_cutoff: drop terms in the Hamiltonian that oscillate faster than this cutoff.\ndisplacement: This can be either \"truncated\"(default) or \"analytic\".\nWhen an atom is irradiated, both the atom's energy and its momentum will generally be  affected. For an atom in a harmonic potential, the exchange of momentum can be modeled as  a displacement operation D(α=iηe^-iνt) = expαa^ - α^*a, where η is the  Lamb-Dicke parameter, which can be described equivalently as either being proportional to  the square root of the ratio of the recoil frequency with the ground state energy of the  atom's motion or as the ratio of the spread of the ground state wavefunction to the  wavelength of the laser.\nWhen \"truncated\" is selected, the matrix elements of D(α) are computed by  constructing α^* a αa^ in a truncated basis (according to the dimension specified in  your model) and then exponentiating their difference. This has the advantage, amongst  other things, of guaranting unitarity.\nIf \"analytic\" is selected, then the matrix elements are computed assuming an infinite-  dimensional Hilbert space.\nFor small displacements (η  N, where N is the dimension of the motion's Hilbert  space), both of these methods will be good approximations.\ntime_dependent_eta::Bool: In addition to impacting the vibrational subspace directly, a  change in the trap frequency, δν, will also change the Lamb-Dicke parameter. Since  typically δνν, this effect will be small η  η₀(1 + δν2ν) and doesn't warrant  the additional computational resources needed to calculate and update it in time. In this  case, we can set time_dependent_eta=false (default), which will set η(t) = η₀.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.intensity!-Tuple{Laser, Function}","page":"API","title":"IonSim.intensity!","text":"intensity(laser::Laser, I::Union{Function,Real})\n\nSets the intensity of laser to I.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.intensity-Tuple{Laser}","page":"API","title":"IonSim.intensity","text":"intensity(laser::Laser)::Function\n\nReturns the laser's intensity laser.I (in W/m²) as a function of time\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.intensity_from_pitime!-Tuple{Laser, Real, Ion, Tuple, NamedTuple{(:x, :y, :z), T} where T<:Tuple}","page":"API","title":"IonSim.intensity_from_pitime!","text":"intensity_from_pitime!(\n    laser::Laser, pi_time::Real, ion::Ion, transition::Tuple,\n    Bhat::NamedTuple{(:x,:y,:z)}\n)\nintensity_from_pitime!(\n    laser, pi_time::Real, ion, transition::Tuple, chamber::Chamber\n)\n\nSame as intensity_from_pitime, but updates laser[:I] in-place.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.intensity_from_pitime-Tuple{Laser, Real, Ion, Tuple, Chamber}","page":"API","title":"IonSim.intensity_from_pitime","text":"intensity_from_pitime(\n    laser, pi_time::Real, ion, transition::Tuple, chamber::Chamber\n    )\n\nCompute the intensity needed to get a certain pi_time with a certain resonant laser-ion transition within chamber, which defines the magnetic field direction. laser may be either a Laser or an Int indicating the desired laser's index within chamber. ion may be either an Ion or an Int indicating the desired ion's index within chamber.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.intensity_from_pitime-Tuple{Laser, Real, Ion, Tuple, NamedTuple{(:x, :y, :z), T} where T<:Tuple}","page":"API","title":"IonSim.intensity_from_pitime","text":"intensity_from_pitime(\n    laser::Laser, pi_time::Real, ion::Ion, transition::Tuple,\n    Bhat::NamedTuple{(:x,:y,:z)}\n)\n\nCompute the intensity needed to get a certain pi_time with a certain resonant laser-ion transition, in the presence of a magnetic field pointing in the direction Bhat.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.intensity_from_rabifrequency!-Tuple{Laser, Real, Ion, Tuple, NamedTuple{(:x, :y, :z), T} where T<:Tuple}","page":"API","title":"IonSim.intensity_from_rabifrequency!","text":"intensity_from_rabifrequency!(\n    laser::Laser, rabi_frequency::Real, ion::Ion, transition::Tuple,\n    Bhat::NamedTuple{(:x,:y,:z)}\n)\nintensity_from_rabifrequency!(\n    laser, rabi_frequency::Real, ion, transition::Tuple, chamber::Chamber\n)\n\nSame as intensity_from_rabifrequency!, but updates laser[:I] in-place.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.intensity_from_rabifrequency-Tuple{Laser, Real, Ion, Tuple, Chamber}","page":"API","title":"IonSim.intensity_from_rabifrequency","text":"intensityfromrabifrequency(         laser, rabifrequency::Real, ion, transition::Tuple, chamber::Chamber         ) Compute the intensity needed to get a certain `rabifrequencywith a certain resonantlaser-iontransitionwithinchamber, which defines the magnetic field direction.lasermay be either a Laser or an Int indicating the desired laser's index withinchamber.ionmay be either an Ion or an Int indicating the desired ion's index withinchamber.laserandion` must either both be indices or both their respective Structs.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.intensity_from_rabifrequency-Tuple{Laser, Real, Ion, Tuple, NamedTuple{(:x, :y, :z), T} where T<:Tuple}","page":"API","title":"IonSim.intensity_from_rabifrequency","text":"intensity_from_rabifrequency(\n    laser::Laser, rabi_frequency::Real, ion::Ion, transition::Tuple,\n    Bhat::NamedTuple{(:x,:y,:z)}\n)\n\nCompute the intensity needed to get a certain rabi_frequency with a certain resonant laser-ion transition, in the presence of a magnetic field pointing in the direction Bhat.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.ionnumber-Tuple{Ion}","page":"API","title":"IonSim.ionnumber","text":"ionnumber(ion::Ion)\n\nReturns ion's number in its IonTrap ion.ionnumber If ion has not been added to an IonTrap, returns missing.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.ionposition-Tuple{Ion}","page":"API","title":"IonSim.ionposition","text":"ionposition(ion::Ion) Returns ion's position in its IonTrap, ion.ionposition in m. If ion has not been added to an IonTrap, returns missing.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.ionpositions-Tuple{Any}","page":"API","title":"IonSim.ionpositions","text":"ionpositions(chain::LinearChain)\n\nReturns the positions of the ions in chain in meters.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.ionprojector-Tuple{IonTrap, Vararg{Union{Int64, String, Tuple{String, Real}}, N} where N}","page":"API","title":"IonSim.ionprojector","text":"ionprojector(obj, sublevels...; only_ions=false)\n\nIf obj<:IonTrap this will return ψ₁ψ₁ψ_Nψ_N𝟙 where ψᵢ = obj.ions[i][sublevels[i]] and the identity operator 𝟙 is over all of the COM modes considered in obj.\n\nIf only_ions=true, then the projector is defined only over the ion subspace.\n\nIf instead obj<:Chamber, then this is the same as obj = Chamber.iontrap.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.ions-Tuple{Chamber}","page":"API","title":"IonSim.ions","text":"\"     ions(T::Chamber) Returns a list of the ions in the Chamber.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.ionstate-Tuple{Ion, Tuple{String, Real}}","page":"API","title":"IonSim.ionstate","text":"ionstate(ion::Ion, sublevel)\n\nRetuns the ket corresponding to the Ion being in state sublevel. Options: sublevel <: Tuple{String,Real}: Specifies full sublevel name sublevel <: String: Specifies sublevel alias sublevel <: Int: Returns the sublevelth eigenstate\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.ionstate-Tuple{IonTrap, Vector{T} where T}","page":"API","title":"IonSim.ionstate","text":"ionstate(object::Union{IonTrap, Chamber}, sublevels)\n\nIf N = length(ions(object)), returns N-dimensional ket corresponding to the ions being in the state sublevel₁sublevel₂sublevel_N.\n\nsublevels must be an length-N Vector, with each element specifying its corresponding ion's sublevel, using the same syntax as in ionstate(ion::Ion, sublevel).\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.iontrap!-Tuple{Chamber, IonTrap}","page":"API","title":"IonSim.iontrap!","text":"iontrap!(chamber::Chamber, iontrap::IonTrap)\n\nSets chamber.iontrap to iontrap\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.iontrap-Tuple{Chamber}","page":"API","title":"IonSim.iontrap","text":"iontrap(chamber::Chamber)\n\nReturns the IonTrap struct associated with chamber, chamber.iontrap\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.lambdicke-Tuple{VibrationalMode, Ion, Laser}","page":"API","title":"IonSim.lambdicke","text":"lambdicke(V::VibrationalMode, I::Ion, L::Laser)\n\nThe Lamb-Dicke parameter:  kcos(theta)sqrtfrachbar2mnu  for a given vibrational mode, ion and laser.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.landegf","page":"API","title":"IonSim.landegf","text":"landegf(l::Real, j::Real, f::Real, i::Real, s::Real=1//2)\n\nLandé g-factor of hyperfine energy level\n\nargs\n\nl: orbital angular momentum quantum number\nj: electron total angular momentum quantum number\nf: total angular momentum quantum number\ni: nuclear spin angular momentum quantum number\ns: electronic spin angular momentum quantum number (defaults to 1/2)\n\n\n\n\n\n","category":"function"},{"location":"api.html#IonSim.landegf-Tuple{Ion, String}","page":"API","title":"IonSim.landegf","text":"landegf(I::Ion, level::String)\n\nlandegf for the quantum numbers of level in I.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.lasers!-Tuple{Chamber, Vector{Laser}}","page":"API","title":"IonSim.lasers!","text":"lasers!(chamber::Chamber, lasers::Vector{Laser})\n\nSets chamber.lasers to lasers\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.lasers-Tuple{Chamber}","page":"API","title":"IonSim.lasers","text":"lasers(chamber::Chamber)::Vector{Laser}\n\nReturns Vector of Lasers inside chamber, chamber.lasers\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.level-Tuple{Ion, Tuple{String, Real}}","page":"API","title":"IonSim.level","text":"level(I::Ion, sublevel)\n\nRetuns the energy level of I corresponding to sublevel.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.levels-Tuple{Ion}","page":"API","title":"IonSim.levels","text":"levels(I::Ion)\n\nReturns array of all energy levels of I.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.leveltransitions-Tuple{Ion}","page":"API","title":"IonSim.leveltransitions","text":"leveltransitions(I::Ion)\n\nReturns all allowed transitions between levels of I as a vector of Tuple{String,String}.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.lifetime-Tuple{Ion, String}","page":"API","title":"IonSim.lifetime","text":"lifetime(I::Ion, level::String)\n\nComputes lifetime of level by summing the transition rates out of level. The sum is taken   over all levels that the species may have, rather than the levels present in the instance I.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.manualshift!-Tuple{Ion, Dict}","page":"API","title":"IonSim.manualshift!","text":"manualshift!(I::Ion, manualshift_dict::Dict)\n\nApplies manualshift(I, sublevel, shift) to all pairs sublevel => shift of the Dict manual_shift_dict.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.manualshift!-Tuple{Ion, Tuple{String, Real}, Real}","page":"API","title":"IonSim.manualshift!","text":"manualshift!(I::Ion, sublevel, shift::Real)\n\nApplies a manual shift shift to the chosen sublevel of I (overwriting any previously assigned manual shift).\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.manualshift-Tuple{Ion, Tuple{String, Real}}","page":"API","title":"IonSim.manualshift","text":"manualshift(I::Ion, sublevel)\n\nReturns the assigned manual shift of sublevel of Ion I.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.manualshift-Tuple{Ion}","page":"API","title":"IonSim.manualshift","text":"manualshift(ion::Ion)\n\nReturns the Dict of manualshift for ion's energy levels ion.manualshift\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.mass-Tuple{Ion}","page":"API","title":"IonSim.mass","text":"mass(ion::Ion)\n\nReturns the mass of ion in kg.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.matrixelement","page":"API","title":"IonSim.matrixelement","text":"matrixelement(ion::Ion, transition::Tuple, I::Real, ϵhat::NamedTuple, khat::NamedTuple, Bhat::NamedTuple=(;z=1))\n\nComputes the matrix elements (units of Hz) between two energy sublevels args\n\nion: Ion undergoing transition\ntransition: Tuple of sublevels (full names or aliases) between which the transition is being calculated. Must be formatted such that energy(transition[2]) > energy(transition[1])\nI: Intensity of the driving field\nϵhat: Unit vector of light polarization\nkhat: Unit vector of light wavevector\nBhat: Unit vector of magnetic field\n\n\n\n\n\n","category":"function"},{"location":"api.html#IonSim.matrixelement-Tuple{Ion, Tuple, Laser, Chamber, Real}","page":"API","title":"IonSim.matrixelement","text":"matrixelement(ion, transition::Tuple, laser, chamber::Chamber, time::Real)\n\nCalls matrixelement(ion, transition, I, ϵhat, khat, Bhat) with I, ϵhat, and khat evaluated for laser at time time, and Bhat evaluated for chamber.\n\nion may be either an Ion or an Int indicating the desired ion's index within chamber. laser may be either a Laser or an Int indicating the desired laser's index within chamber. ion and laser must either both be indices or both their respective Structs.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.modecutoff!-Tuple{Chamber, Int64}","page":"API","title":"IonSim.modecutoff!","text":"modecutoff!(T::Chamber, N::Int)\n\nSets the upper bound of the Hilbert space of all VibrationalModes in the IonTrap of T to be the Fock state N.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.modecutoff!-Tuple{LinearChain, Int64}","page":"API","title":"IonSim.modecutoff!","text":"modecutoff!(lc::LinearChain, N::Int)\n\nSets the upper bound of the Hilbert space of all VibrationalModes in lc to be the Fock  state N.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.modecutoff!-Tuple{VibrationalMode, Int64}","page":"API","title":"IonSim.modecutoff!","text":"modecutoff!(mode::VibrationalMode, N::Int)\n\nSets the upper bound of the Hilbert space of mode to be the Fock state N.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.modecutoff-Tuple{VibrationalMode}","page":"API","title":"IonSim.modecutoff","text":"modecutoff\n\nReturns mode.N\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.modes-Tuple{Chamber}","page":"API","title":"IonSim.modes","text":"modes(T::Chamber)\n\nReturns modes(iontrap(T))\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.modes-Tuple{LinearChain}","page":"API","title":"IonSim.modes","text":"modes(lc::LinearChain)\n\nReturns an array of all of the selected VibrationalModes in the LinearChain. The order is [lc.x..., lc.y..., lc.z...].\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.modestructure-Tuple{VibrationalMode}","page":"API","title":"IonSim.modestructure","text":"modestructure(mode::VibrationalMode)\n\nReturns mode.modestructure\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.nuclearspin-Tuple{Ion}","page":"API","title":"IonSim.nuclearspin","text":"nuclearspin(ion::Ion)\n\nReturns the nuclear spin of ion.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.number-Tuple{VibrationalMode}","page":"API","title":"IonSim.number","text":"number(v::VibrationalMode)\n\nReturns the number operator for v such that:  number(v) * v[i] = i * v[i].\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.phase!-Tuple{Laser, Function}","page":"API","title":"IonSim.phase!","text":"phase!(laser::Laser, ϕ::Union{Function,Real})\n\nSets the phase of laser to ϕ.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.phase-Tuple{Laser}","page":"API","title":"IonSim.phase","text":"phase(laser::Laser)::Function\n\nReturns the laser's phase laser.ϕ in (in radians) as a function of time\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.pointing!-Tuple{Laser, Array{Tuple{T1, T2}, 1} where {T2<:Real, T1<:Int64}}","page":"API","title":"IonSim.pointing!","text":"pointing!(laser::Laser, p::Vector{Tuple{T1, T2}} where T1<:Int where T2<:Real)\n\nSets the pointing of laser with p. length(p) should be equal to the number of ions in the Chamber containing laser.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.pointing-Tuple{Laser}","page":"API","title":"IonSim.pointing","text":"pointing(laser::Laser)::Vector\n\nReturn's the laser's pointing information laser.pointing if laser has been added to a Chamber.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.polarization!-Tuple{Laser, NamedTuple{(:x, :y, :z), T} where T<:Tuple}","page":"API","title":"IonSim.polarization!","text":"polarization!(laser::Laser, ϵ::ReNamedTuple{(:x, :y, :z)})\n\nSets the polarization of laser to ϵ.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.polarization-Tuple{Laser}","page":"API","title":"IonSim.polarization","text":"polarization(laser::Laser)::NamedTuple{(:x, :y, :z)}\n\nReturns the laser's polarization unit vector laser.ϵ\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.quantumnumbers-Tuple{Ion, Tuple{String, Real}}","page":"API","title":"IonSim.quantumnumbers","text":"quantumnumbers(I::Ion, level::String)\nquantumnumbers(I::Ion, sublevel)\n\nReturns the quantum numbers of an energy level or sublevel of I as a NamedTuple. If second argument is a level, returns (:n, :i, :s, :l, :j, :f) If second argument is a sublevel, returns (:n, :i, :s, :l, :j, :f, :m)\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.selectedmodes-Tuple{LinearChain}","page":"API","title":"IonSim.selectedmodes","text":"selectedmodes(chain::LinearChain)\n\nReturns chain.selectedmodes\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.shape-Tuple{Ion}","page":"API","title":"IonSim.shape","text":"shape(ion::Ion)\n\nReturns the dimension of the ion's Hilbert space ion.shape\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.shape-Tuple{VibrationalMode}","page":"API","title":"IonSim.shape","text":"shape(mode::VibrationalMode)\n\nReturns mode.shape\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.sigma-Union{Tuple{T}, Tuple{Ion, T, T}} where T<:Union{Int64, String, Tuple{String, Real}}","page":"API","title":"IonSim.sigma","text":"sigma(ion::Ion, ψ1::sublevel[, ψ2::sublevel])\n\nReturns ψ1ranglelangle ψ2, where ψ_irangle corresponds to the state returned by ion[ψᵢ].\n\nIf ψ2 is not given, then ψ1ranglelangle ψ1 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.speciesproperties-Tuple{Ion}","page":"API","title":"IonSim.speciesproperties","text":"speciesproperties(ion::Ion)\n\nReturns the IonProperties struct of the ion species, which contains species-specific information including mass, energy levels, and transitions.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.sublevel-Tuple{Ion, String}","page":"API","title":"IonSim.sublevel","text":"sublevel(I::Ion, alias::String)\n\nReturns the sublevel corresponding to the given alias alias of I. Inverse function of sublevelalias.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.sublevelalias!-Tuple{Ion, Array{Tuple{Tuple{String, R}, String}, 1} where R<:Real}","page":"API","title":"IonSim.sublevelalias!","text":"sublevelalias!(I::Ion, aliasassignments)\n\naliasassignments specifies which aliases should be assigned to which sublevels. There are two options to do this:\n\naliasassignments is a Vector of Tuples, with the first element of each being the sublevel (sublevel::Tuple{String,Real}) and the second being its assigned alias (alias::String)\naliasassignments is a Dict with the format alias::String => sublevel::Tuple{String,Real}\n\nCalls sublevelalias!(I, sublevel, alias) for each pair sublevel, alias.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.sublevelalias!-Tuple{Ion, Tuple{String, Real}, String}","page":"API","title":"IonSim.sublevelalias!","text":"sublevelalias!(I::Ion, sublevel::Tuple{String,Real}, alias::String)\n\nAssigns an alias alias to sublevel of I. This then allows one to pass alias in place of sublevel (for I only) into any function which accepts a sublevel as an argument.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.sublevelalias-Tuple{Ion, Tuple{String, Real}}","page":"API","title":"IonSim.sublevelalias","text":"sublevelalias(I::Ion, sublevel::Tuple{String,Real})\n\nReturns the alias assined to sublevel of I. If no alias is assigned, returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.sublevelaliases-Tuple{Ion}","page":"API","title":"IonSim.sublevelaliases","text":"sublevelaliases(ion::Ion)\n\nReturns a Dict specifying all aliases assigned to sublevels of ion, in the format alias => sublevel, ion.sublevelalias\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.sublevels-Tuple{Ion}","page":"API","title":"IonSim.sublevels","text":"sublevels(ion::Ion)\n\nReturns the energy sublevels in the Hilbert space of ion, ion.sublevels\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.subleveltransitions-Tuple{Ion}","page":"API","title":"IonSim.subleveltransitions","text":"subleveltransitions(I::Ion)\n\nReturns all allowed transitions between sublevels of I as a vector of Tuple{S,S} where  S=Tuple{String,Real}.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.transitionfrequency-Tuple{Ion, Tuple, Chamber}","page":"API","title":"IonSim.transitionfrequency","text":"transitionfrequency(ion, transition::Tuple, chamber::Chamber; ignore_manualshift=false)\n\nReturns The frequency of the transition transition including the Zeeman shift experienced by ion given its position in T. ion may be either an Ion or an Int indicating the desired ion's index within chamber.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.transitionfrequency-Tuple{Ion, Tuple}","page":"API","title":"IonSim.transitionfrequency","text":"transitionfrequency(I::Ion, transition::Tuple; B=0, ignore_manualshift=false)\n\ntransition is a Tuple of two sublevels or levels.\n\nComputes the absolute values of the difference in energies between transition[1] and transition[2].\n\nIf between sublevels, then the Zeeman shift may be included by setting the value of the magnetic field B, and manual shifts may be omitted by setting ignore_manualshift=true.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.transitionmultipole-Tuple{Ion, Tuple{String, String}}","page":"API","title":"IonSim.transitionmultipole","text":"transitionmultipole(I::Ion, leveltransition::Tuple)\n\nReturns the transition multiple ('E1', 'E2', etc.) corresponding to the transition leveltransition[1] -> leveltransition[2]. The first level must be the lower level and the second must be the upper level.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.transitionwavelength-Tuple{Ion, Tuple, Chamber}","page":"API","title":"IonSim.transitionwavelength","text":"transitionwavelength(ion, transition::Tuple, chamber::Chamber; ignore_manualshift=false)\n\nReturns The wavelength of the transition transition including the Zeeman shift experienced by ion given its position in T. ion may be either an Ion or an Int indicating the desired ion's index within chamber.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.transitionwavelength-Tuple{Ion, Tuple}","page":"API","title":"IonSim.transitionwavelength","text":"transitionwavelength(I::Ion, transition::Tuple; B=0, ignore_manualshift=false)\n\nReturns the wavelength corresponding to transitionfrequency(I::Ion, transition::Tuple; B=0, ignore_manualshift=false).\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.visualize-Tuple{LinearChain, Any, Any}","page":"API","title":"IonSim.visualize","text":"visualize(lc::LinearChain, axis::String, modes::Vector{<:Int}, format=\"bars\")\n\nVisualize the normal mode structure of a lc as a Plots.jl plot. axis can either be one of \"x\", \"y\", \"z\" or a NamedTuple{(:x,:y,:z)}. modes is a vector of indices  selecting which modes should be included in the plot. Slicing is supported. format can be  either \"bars\" or \"circles.\"\n\nNote that the indexing refers to the full normal mode description and not the subset  selectedmodes(lc).\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.visualize-Tuple{Tuple{Float64, Vector{Float64}}, NamedTuple{(:x, :y, :z), T} where T<:Tuple}","page":"API","title":"IonSim.visualize","text":"visualize(\n    vm::Tuple{Float64, Vector{Float64}}, axis::NamedTuple{(:x, :y, :z)}; format=\"bars\"\n)\n\nSame thing but input a normal mode description as a tuple with first element the eigenfrequency and second the eigenvector.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.visualize-Tuple{VibrationalMode}","page":"API","title":"IonSim.visualize","text":"visualize(vm::VibrationalMode; format=\"bars\")\n\nVisualize the normal mode structure of a vm as a Plots.jl plot. format can be either bar or ions. format can be either \"bars\" or \"circles.\"\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.wavelength!-Tuple{Laser, Real}","page":"API","title":"IonSim.wavelength!","text":"wavelength!(laser::Laser, λ::Real)\n\nSets the wavelength of laser to λ.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.wavelength-Tuple{Laser}","page":"API","title":"IonSim.wavelength","text":"wavelength(laser::Laser)::Real\n\nReturns the laser's wavelength laser.λ (in m)\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.wavelength_from_transition!-Tuple{Laser, Ion, Tuple, Chamber}","page":"API","title":"IonSim.wavelength_from_transition!","text":"wavelength_from_transition!(laser::Laser, ion, transition::Tuple, chamber::Chamber)\n\nSets the wavelength of laser to the transition wavelength of transition in the ion ion, at the magnetic field seen by ion in chamber. ion may be either an Ion or an Int indicating the desired ion's index within chamber.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.wavelength_from_transition!-Tuple{Laser, Ion, Tuple, Real}","page":"API","title":"IonSim.wavelength_from_transition!","text":"wavelength_from_transition!(laser::Laser, ion::Ion, transition::Tuple, B::Real)\n\nSets the wavelength of laser to the transition wavelength of transition in the ion ion, at a magnetic field value given by B.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.wavevector!-Tuple{Laser, NamedTuple{(:x, :y, :z), T} where T<:Tuple}","page":"API","title":"IonSim.wavevector!","text":"wavevector!(laser::Laser, k::ReNamedTuple{(:x, :y, :z)})\n\nSets the wavevector of laser to k.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.wavevector-Tuple{Laser}","page":"API","title":"IonSim.wavevector","text":"wavevector(laser::Laser)::NamedTuple{(:x, :y, :z)}\n\nReturns the laser's wavevector unit vector laser.k\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.xmodes-Tuple{Chamber}","page":"API","title":"IonSim.xmodes","text":"xmodes(T::Chamber)\n\nReturns an array of all of the selected VibrationalModes in the x-direction in the Chamber's IonConfiguration.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.xmodes-Tuple{LinearChain}","page":"API","title":"IonSim.xmodes","text":"xmodes(lc::LinearChain)\n\nReturns an array of all of the selected VibrationalModes in the x-direction in the  LinearChain.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.ymodes-Tuple{Chamber}","page":"API","title":"IonSim.ymodes","text":"ymodes(T::Chamber)\n\nReturns an array of all of the selected VibrationalModes in the y-direction in the Chamber's IonConfiguration.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.ymodes-Tuple{LinearChain}","page":"API","title":"IonSim.ymodes","text":"ymodes(lc::LinearChain)\n\nReturns an array of all of the selected VibrationalModes in the y-direction in the  LinearChain.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.zeemanshift-Tuple{Ion, Tuple{String, Real}, Real}","page":"API","title":"IonSim.zeemanshift","text":"zeemanshift(I::Ion, sublevel, B::Real)\n\nReturns the Zeeman shift at a magnetic field of B of sublevel of I. If sublevel has a custom g-factor defined, then this is used. Otherwise, landegf is used  to compute the Landé g-factor. Zeeman shift calculated as ΔE = (μ_Bħ)  g_f  B  m  2π\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.zeemanshift-Tuple{Ion, Union{String, Tuple{String, Real}}, Chamber}","page":"API","title":"IonSim.zeemanshift","text":"zeemanshift(I, sublevel, T::Chamber)\n\nCalls zeemanshift(I::Ion, sublevel, B::Real) with B evaluated for ion I in T. I may be either an Ion or an Int indicating the desired ion's index within T.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.zeromanualshift!-Tuple{Ion}","page":"API","title":"IonSim.zeromanualshift!","text":"zeromanualshift!(I::Ion)\n\nSets the manual shift of all sublevels of I to zero.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.zmodes-Tuple{Chamber}","page":"API","title":"IonSim.zmodes","text":"zmodes(T::Chamber)\n\nReturns an array of all of the selected VibrationalModes in the z-direction in the Chamber's IonConfiguration.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.zmodes-Tuple{LinearChain}","page":"API","title":"IonSim.zmodes","text":"zmodes(lc::LinearChain)\n\nReturns an array of all of the selected VibrationalModes in the z-direction in the  LinearChain.\n\n\n\n\n\n","category":"method"},{"location":"api.html#QuantumOpticsBase.coherentthermalstate-Tuple{VibrationalMode, Real, Number}","page":"API","title":"QuantumOpticsBase.coherentthermalstate","text":"coherentthermalstate(v::VibrationalMode, n̄::Real, α::Number; method=\"truncated)\n\nReturns a displaced thermal state for v, which is created by applying a displacement operation to a thermal state. The mean occupation of the thermal state is n̄ and α is the complex amplitude of the displacement.\n\nmethod can be either \"truncated\" or \"analytic\" and this argument determines how the displacement operator is computed (see: displace) .\n\n\n\n\n\n","category":"method"},{"location":"api.html#QuantumOpticsBase.displace-Tuple{VibrationalMode, Number}","page":"API","title":"QuantumOpticsBase.displace","text":"displace(v::VibrationalMode, α::Number; method=\"truncated\")\n\nReturns the displacement operator D(α) corresponding to v.\n\nIf method=\"truncated\" (default), the matrix elements are computed according to D(α) = expαa^ - α^*a where a and a^ live in a truncated Hilbert space of dimension modecutoff(v)+1. Otherwise if method=\"analytic\", the matrix elements are computed assuming an infinite-dimension Hilbert space. In general, this option will not return a unitary operator.\n\n\n\n\n\n","category":"method"},{"location":"api.html#QuantumOpticsBase.fockstate-Tuple{VibrationalMode, Int64}","page":"API","title":"QuantumOpticsBase.fockstate","text":"fockstate(v::VibrationalMode, N::Int)\n\nReturns the fockstate N on v.\n\n\n\n\n\n","category":"method"},{"location":"api.html#QuantumOpticsBase.thermalstate-Tuple{VibrationalMode, Real}","page":"API","title":"QuantumOpticsBase.thermalstate","text":"thermalstate(v::VibrationalMode, n̄::Real; method=\"truncated\")\n\nReturns a thermal density matrix with a^a  n. Note: approximate because we are dealing with a finite dimensional Hilbert space that must be normalized.\n\nmethod can be set to either \"truncated\" (default) or \"analytic\". In the former case, the thermal density matrix is generated according to the formula: ρ_th = exp(-νa^aT)  Tr exp(-νa^aT). In the later case, the analytic formula, assuming an infinite-dimensional Hilbert space, is used: ρ_th_ij = δ_ij fracnⁱ(n+1)^i+1\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.analytical.molmersorensen2ion-Tuple{Any, Real, Real, Real, Real, Real}","page":"API","title":"IonSim.analytical.molmersorensen2ion","text":"molmersorensen2ion(tspan, Ω::Real, ν::Real, δ::Real, η::Real, n̄::Real)\n\nref <br> Assumes vibrational mode starts in a thermal state with: langle a^dagger arangle = n  and ions start in doubly ground state. Returns (ρgg, ρee), the population in the doubly  ground and doubly excited state, respectively. Ω ν δ = Hz\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.analytical.rabiflop-Tuple{Any, Real, Real, Real}","page":"API","title":"IonSim.analytical.rabiflop","text":"rabiflop(tspan, Ω::Real, η::Real, n̄::Real; s::Int=0) <br>\n\nSingle ion rabi flop. Returns: sum_n=0^ p_n sin^2(Omega_n t) <br> with Omega_n = Ωe^-η^22η^ssqrtfracn(n+s)L_n^s(η^2) <br> where s is the order of the (blue) sideband that we are driving and L_n^s is the associated Laguerre polynomial. ref\n\n\n\n\n\n","category":"method"},{"location":"api.html#IonSim.PhysicalConstants.c","page":"API","title":"IonSim.PhysicalConstants.c","text":"c = 2.99792458e8 m/s <br> (speed of light in vacuum)\n\n\n\n\n\n","category":"constant"},{"location":"api.html#IonSim.PhysicalConstants.c_rank1","page":"API","title":"IonSim.PhysicalConstants.c_rank1","text":"c_rank1: Matrix of spherical basis vectors (defined in e.g. Quantum dynamics of cold trapped ions with application to quantum computation, Appl. Phys. B 66, 181-190 (1998).\n\nUseful for converting between coordinates of rank-1 spherical tensors and Cartesian coordinates\n\n\n\n\n\n","category":"constant"},{"location":"api.html#IonSim.PhysicalConstants.c_rank2","page":"API","title":"IonSim.PhysicalConstants.c_rank2","text":"c_rank2: Matrix of spherical basis rank-2 tensors (defined in e.g. Quantum dynamics of cold trapped ions with application to quantum computation, Appl. Phys. B 66, 181-190 (1998).\n\nUseful for converting between coordinates of rank-2 spherical tensors and Cartesian coordinates\n\n\n\n\n\n","category":"constant"},{"location":"api.html#IonSim.PhysicalConstants.e","page":"API","title":"IonSim.PhysicalConstants.e","text":"e = 1.60217662e-19 C <br> (charge of electron)\n\n\n\n\n\n","category":"constant"},{"location":"api.html#IonSim.PhysicalConstants.eye3","page":"API","title":"IonSim.PhysicalConstants.eye3","text":"eye3: Three-dimensional identity matrix\n\n\n\n\n\n","category":"constant"},{"location":"api.html#IonSim.PhysicalConstants.kB","page":"API","title":"IonSim.PhysicalConstants.kB","text":"kB = 1.38064852e-23 m^2kg(s^2K)\n\n\n\n\n\n","category":"constant"},{"location":"api.html#IonSim.PhysicalConstants.ħ","page":"API","title":"IonSim.PhysicalConstants.ħ","text":"ħ = 1.0545718e-34 m²kg/s <br> (Planck's constant / 2π)\n\n\n\n\n\n","category":"constant"},{"location":"api.html#IonSim.PhysicalConstants.α","page":"API","title":"IonSim.PhysicalConstants.α","text":"α = e²/4πϵ₀ħc``\n\n\n\n\n\n","category":"constant"},{"location":"api.html#IonSim.PhysicalConstants.μB","page":"API","title":"IonSim.PhysicalConstants.μB","text":"μB = 9.27400994e-24 J⋅T⁻¹ <br> (Bohr Magneton)\n\n\n\n\n\n","category":"constant"},{"location":"api.html#IonSim.PhysicalConstants.ϵ₀","page":"API","title":"IonSim.PhysicalConstants.ϵ₀","text":"ϵ₀ = 8.85418782e-12 (s^4A^2)  (m^3 kg)\n\n\n\n\n\n","category":"constant"},{"location":"objects/iontraps.html#IonTrap","page":"IonTrap","title":"IonTrap","text":"","category":"section"},{"location":"objects/iontraps.html","page":"IonTrap","title":"IonTrap","text":"Once you've defined a number of ions<:Ion, the next step is to put them together into an IonTrap. ","category":"page"},{"location":"objects/iontraps.html","page":"IonTrap","title":"IonTrap","text":"DocString: IonTrap","category":"page"},{"location":"objects/iontraps.html","page":"IonTrap","title":"IonTrap","text":"The following subtypes of IonTrap are currently implemented:","category":"page"},{"location":"objects/iontraps.html","page":"IonTrap","title":"IonTrap","text":"LinearChain: A Linear Coulomb crystal, which may be composed of ions that have different mass and or charge.","category":"page"},{"location":"objects/iontraps.html","page":"IonTrap","title":"IonTrap","text":"And the following configurations are under consideration for implementation:","category":"page"},{"location":"objects/iontraps.html","page":"IonTrap","title":"IonTrap","text":"CoulombCrystal: A two-dimensional ion crystal.\nRing: A one-dimensional chainof ions in a ring configuration.","category":"page"},{"location":"objects/emfields.html#ElectroMagneticField","page":"ElectroMagneticField","title":"ElectroMagneticField","text":"","category":"section"},{"location":"objects/chambers.html#Chamber","page":"Chamber","title":"Chamber","text":"","category":"section"},{"location":"objects/chambers.html","page":"Chamber","title":"Chamber","text":"This controls the parameters of the ion trap apparatus.","category":"page"},{"location":"examples.html#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Find all of our examples at https://examples.ionsim.org.","category":"page"},{"location":"hamiltonian.html#Constructing-the-Hamiltonian","page":"Constructing the Hamiltonian","title":"Constructing the Hamiltonian","text":"","category":"section"},{"location":"hamiltonian.html","page":"Constructing the Hamiltonian","title":"Constructing the Hamiltonian","text":"This is what we are trying to solve for.","category":"page"},{"location":"objects/waveforms.html#WaveForm","page":"WaveForm","title":"WaveForm","text":"","category":"section"},{"location":"objects/ions.html#Ion","page":"Ion","title":"Ion","text":"","category":"section"},{"location":"timeevolution/quantumnoise.html#Quantum-Noise","page":"Quantum Noise","title":"Quantum Noise","text":"","category":"section"},{"location":"timeevolution/solve.html#Solve","page":"Solve","title":"Solve","text":"","category":"section"},{"location":"index.html#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"<!-- Place this tag in your head or just before your close body tag. -->\n<script async defer src=\"https://buttons.github.io/buttons.js\"></script>\n<!-- Place this tag where you want the button to render. -->\n<a class=\"github-button\" href=\"https://github.com/HaeffnerLab/IonSim.jl\" data-color-scheme=\"no-preference: light_high_contrast; light: light_high_contrast; dark: dark_high_contrast;\" data-icon=\"octicon-star\" data-size=\"large\" data-show-count=\"true\" aria-label=\"Star HaeffnerLab/IonSim.jl on GitHub\">Star</a>","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"IonSim.jl is a tool to simulate the dynamics of a collection of trapped ions interacting with laser light.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"IonSim primarily performs two jobs:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Keep track of the physical parameters necessary for describing the system, with a structure and nomenclature designed to be intuitive for experimentalists.\nUsing these parameters, construct a function that quickly evaluates the system's Hamiltonian at a particular point in time.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"This functional form of the Hamiltonian can then be used either as input to any of the solvers implemented in QuantumOptics.timeevolution, or in the native solver. The native solver is a thin wrapper around QuantumOptics functions that implement additional checks.","category":"page"},{"location":"index.html#Why-use-it?","page":"Introduction","title":"Why use it?","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"IonSim is designed from an experimentalist's perspective. If you are looking to do efficient simulations of trapped ion systems, with high control of energy levels and vibrational modes, this is the package for you.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The code is MIT-licensed; find the code on GitHub.","category":"page"},{"location":"tutorial.html#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"}]
}
