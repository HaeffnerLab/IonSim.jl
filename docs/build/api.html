<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · IonSim.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://docs.ionsim.org/api.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><script src="assets/js/link-back.js"></script><link href="assets/small-logo.png" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.svg" alt="IonSim.jl logo"/></a><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><a class="tocitem" href="installation.html">Installation</a></li><li><a class="tocitem" href="tutorial.html">Tutorial</a></li><li><span class="tocitem">Constructing a Trapped Ion Experiment</span><ul><li><a class="tocitem" href="objects/ions.html">Ion</a></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">IonTraps</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="objects/iontraps.html">IonTrap</a></li><li><a class="tocitem" href="objects/linearchains.html">LinearChain</a></li><li><a class="tocitem" href="objects/vibrationalmodes.html">VibrationalMode</a></li></ul></li><li><a class="tocitem" href="objects/emfields.html">ElectroMagneticField</a></li><li><a class="tocitem" href="objects/waveforms.html">WaveForm</a></li><li><a class="tocitem" href="objects/chambers.html">Chamber</a></li></ul></li><li><a class="tocitem" href="hamiltonian.html">Constructing the Hamiltonian</a></li><li><span class="tocitem">Simulation</span><ul><li><a class="tocitem" href="timeevolution/solve.html">Solve</a></li><li><a class="tocitem" href="timeevolution/rotatingframes.html">RotatingFrame</a></li><li><a class="tocitem" href="timeevolution/technicalnoise.html">Technical Noise</a></li><li><a class="tocitem" href="timeevolution/quantumnoise.html">Quantum Noise</a></li></ul></li><li><a class="tocitem" href="examples.html">Examples</a></li><li class="is-active"><a class="tocitem" href="api.html">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="api.html">API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="api.html">API</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="IonSim.Chamber" href="#IonSim.Chamber"><code>IonSim.Chamber</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Chamber(;
        iontrap::LinearChain, B::Real=0, Bhat::NamedTuple{(:x,:y,:z)=ẑ, ∇B::Real=0,
         δB::Union{Real,Function}=0, lasers::Vector{Laser}
)</code></pre><p>Information necessary to describe the Hamiltonian for a collection of ions in a linear chain interacting with laser light. <strong>user-defined fields</strong></p><ul><li><code>iontrap&lt;:LinearChain</code></li><li><code>B</code>: A real value describing the mean magnitude of the B-field [Tesla].</li><li><code>Bhat::NamedTuple{(:x,:y,:z)}</code>: Describes the direction of the B-field (defaults to ẑ).</li><li><code>∇B</code>: Magnitude of the B-field gradient. We assume that the gradient always points along the       z-direction. [Tesla / meter]</li><li><code>δB::Function</code>: Time-dependence of the B-field [Tesla]</li><li><code>lasers::Array{&lt;:Laser}</code>: For each laser in the array, the pointing field should contain       an array of <code>Tuple{Int,Real}</code>. The first element specifies the index of an ion       in the <code>ions</code> field that the laser interacts with. The second element specifies a       scaling factor for the strength of that interaction (to be used, e.g., for       modeling cross-talk).</li></ul><p><strong>derived fields</strong></p><ul><li><p><code>_cnst_δB::Bool</code>: A Boolean flag signifying whether or not <code>δB</code> is a constant function.</p></li><li><p><code>basis&lt;:CompositeBasis</code>: The basis for describing the combined system, ions + vibrational       modes. If constructing the Hamiltonian explictly (with <a href="api.html#IonSim.hamiltonian-Tuple{Chamber}"><code>hamiltonian</code></a>), then       the ordering of the basis is set, by convention, as       <span>$ion₁ ⊗ ion₂ ⊗ ... ⊗ ion_N ⊗ mode₁ ⊗ mode₂ ⊗ ... ⊗ mode_N$</span>, where the ion bases are       ordered according to the order in <code>T.iontrap.ions</code> and the vibrational modes       are ordered according to the order in       <code>[T.iontrap.selectedmodes.x, T.iontrap.selectedmodes.y,       T.iontrap.selectedmodes.z]</code>.   E.g. for:</p><p><code>chain = LinearChain(ions=[C1, C2], comfrequencies=(x=2e6,y=2e6,z=1e6),   selectedmodes=(x=[1, 2], y=[], z=[1]))</code></p><p>The ordering of the basis would be</p><p><code>C1.basis ⊗ C2.basis ⊗ chain.selectedmodes.x[1].basis   ⊗ chain.selectedmodes.x[2].basis ⊗ chain.selectedmodes.z[1].basis</code></p><p>Otherwise, the ordering is according to the form of the initial state used in the solver.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/chambers.jl#L38-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.Ion" href="#IonSim.Ion"><code>IonSim.Ion</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Ion</code></pre><p>The physical parameters defining an isolated ion&#39;s internal structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/ions.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.IonInstance" href="#IonSim.IonInstance"><code>IonSim.IonInstance</code></a> — <span class="docstring-category">Type</span></header><section><div><p>IonInstance(selected_sublevels::Vector{Tuple}[, manualshift::Dict]) Ion instance of some species</p><p><code>selected_sublevels</code> specifies which energy sublevels will be present in the Hilbert space of  this Ion instance, as a subset of all possible sublevels.</p><p>Each element of <code>selected_sublevels</code> is a 2-element Tuple <code>(level::String, sublevels)</code>, with the first element being the name of a level and the second specifying which sublevels should be included. Allowed sublevels are those whose magnetic quantum number <code>m</code> is in the set {<code>-f</code>, <code>-f+1</code>, <code>-f+2</code>, ... <code>f-1</code>, <code>f</code>}, where <code>f</code> is the total angular momentum quantum number of <code>level</code>. For each <code>level</code> specified there are three allowed options to specify the set of <code>sublevels</code> to include:</p><ul><li><code>sublevels::Real</code>: Includes only one <code>m = sublevels</code></li><li><code>sublevels::Vector{Real}</code>: Includes all sublevels whose magnetic quantum number <code>m</code> is in <code>sublevels</code></li><li><code>sublevels = &quot;all&quot;</code>: Includes all allowed sublevels</li></ul><p>If an element of <code>selected_sublevels</code> utilizes the first option, specifying a single <code>m</code>, one may optionally may this a 3-element tuple instead: <code>(level::String, m::Real, alias::String)</code>, assinging this particular sublevel the alias <code>alias</code>.</p><p>Omission of a level in <code>selected_sublevels</code> will exclude all sublevels.</p><p><strong>Fields</strong></p><ul><li><code>speciesproperties::IonProperties</code>: Contains constants specifying parameters specific to species</li><li><code>sublevels</code>::Vector{Tuple{String,Real}}: List of all sublevels present in the Hilbert space</li><li><code>sublevelaliases::Dict{String,Tuple}</code>: Dict specifying aliases assigned to sublevels, in the format <code>alias =&gt; sublevel</code></li><li><code>shape</code>::Vector{Int}: Dimension of the Hilbert space</li><li><code>manualshift::OrderedDict</code>: A dictionary with keys denoting the selected levels and values, a real number for describing a shift of the level&#39;s energy. This is just a convenient way to add manual shifts to the simulation, such as Stark shifts off of energy levels not present in the Hilbert space, without additional resources</li><li><code>ionnumber</code>: When the ion is added to an <code>IonTrap</code>, this value keeps track of its order</li><li><code>ionposition</code>: When the ion is added to an <code>IonTrap</code>, this value keeps track of its physical position in meters</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/ions.jl#L852-L877">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.IonProperties" href="#IonSim.IonProperties"><code>IonSim.IonProperties</code></a> — <span class="docstring-category">Type</span></header><section><div><p>IonProperties type.</p><p><strong>Required keywords</strong></p><ul><li><code>mass</code>: Mass of ion in kg</li><li><code>charge</code>: Charge of ion in units of elementary charge</li><li><code>full_level_structure</code>: OrderedDict describing properties of each energy level<ul><li><code>key::String</code>: Name of energy level. Spectroscopic notation encouraged, e.g. <code>&quot;S1/2,f=1&quot;</code></li><li><code>value::NamedTuple(:n, :l, :j, :f, :E)</code>: Quantum numbers <code>n</code>, <code>l</code>, <code>j</code>, <code>f</code>, and energy  <code>E</code> (in Hz)</li></ul></li><li><code>full_transitions</code>: Dict of all allowed transitions between energy levels<ul><li><code>key::Tuple{String,String}</code> Pair of levels, ordered (lower, upper) in energy</li><li><code>value::NamedTuple(:multipole, :einsteinA)</code>: Leading-order multipole of the transition   (e.g. <code>&quot;E1&quot;</code>, <code>&quot;E2&quot;</code>) and Einstein A coefficient (between fine structure levels only;   hyperfine factors are calculated when needed)</li></ul></li></ul><p><strong>Optional keywords</strong></p><ul><li><code>default_sublevel_selection</code>: Default value of <code>selected_sublevels</code> argument in Ion   constructor</li><li><code>gfactors</code>: <code>Dict(level::String =&gt; g::Real)</code> Custom Landé g-factors, if contributions from   higher-than-first-order perturbations are desired</li><li><code>nonlinear_zeeman</code>: <code>Dict</code> describing nonlinear contributions to Zeeman shift of certain   sublevels<ul><li><code>key::Tuple{String,Real}</code>: sublevel name</li><li><code>value::Function(B::Real)</code>: Nonlinear term(s) of Zeeman shift. Full Zeeman shift will be   calculated as the sum of the usual linear term and this function</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/ions.jl#L771-L797">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.IonSimBasis" href="#IonSim.IonSimBasis"><code>IonSim.IonSimBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IonSimBasis</code></pre><p>An abstract type for specialized bases, which are unique to IonSim.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/IonSim.jl#L29-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.IonTrap" href="#IonSim.IonTrap"><code>IonSim.IonTrap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IonTrap</code></pre><p>A physical configuration of ions. Stores a collection of ions and information about their relative center of mass motion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/iontraps.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.Laser" href="#IonSim.Laser"><code>IonSim.Laser</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Laser(;λ=missing, E=0, Δ=0, ϵ=(x̂+ŷ)/√2, k=ẑ, ϕ=0, pointing::Array{Tuple{Int,Real}})</code></pre><p>The physical parameters defining laser light. <strong>args</strong></p><ul><li><code>λ::Union{Real,Missing}</code>: the wavelength of the laser in meters</li><li><code>I::Union{Function,Real}</code>: laser intensity in W/m²</li><li><code>Δ</code>: static detuning from f = c/λ in [Hz]</li><li><code>ϵ::NamedTuple</code>: (ϵ.x, ϵ.y, ϵ.z), polarization direction, requires norm of 1</li><li><code>k::NamedTuple</code>: (k.x, k.y, k.z), propagation direction, requires norm of 1</li><li><code>ϕ::Union{Function,Real}</code>: time-dependent phase. of course, this can also be used to model a    time-dependent detuning. Units are in radians. Note: if this is set to a function of time,   then when constructing a Hamiltonian with the <code>hamiltonian</code> function, the units of time   will be as specified by the <code>timescale</code> keyword argument.</li><li><code>pointing</code>: an array of <code>Tuple{Int,Real}</code> for describing ion-laser pointing configuration.   (first element of the tuple is the index for an ion and the second element is the scaling   factor for the laser&#39;s Efield which must be between 0 and 1).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/lasers.jl#L20-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.LinearChain" href="#IonSim.LinearChain"><code>IonSim.LinearChain</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LinearChain(;
        ions, comfrequencies::NamedTuple{(:x,:y,:z)},
        selectedmodes::NamedTuple{(:x,:y,:z), N::Int=10
    )</code></pre><p>Generates and stores all of the information necessary to describe a collection of ions trapped  in a 3D harmonic potential and forming a linear coulomb crystal. Relevant to calculating the normal mode structure of the linear chain is the charge, mass  and ordering of the ions.</p><p><strong>user-defined fields</strong></p><ul><li><code>ions</code>: An iterable list of ions that compose the linear Coulomb crystal</li><li><code>comfrequencies::NamedTuple{(:x,:y,:z)</code>: Describes the COM frequencies    <code>(x=ν_x, y=ν_y, z=ν_z)</code>. The z-axis is taken to be along the crystal&#39;s axis of    symmetry. Note that these only correspond to true COM modes if all ions have the same   mass, otherwise this is a misnomer and corresponds to the smallest (largest) eigenfrequency   mode in the axial (radial) directions. Note: we assume that <code>ν_x &gt; ν_y &gt; ν_z</code>.</li><li><code>selectedmodes::NamedTuple{(:x,:y,:z)}</code>:  e.g. <code>selectedmodes=(x=[1], y=[1, 2:3], z=[:])</code>.   Specifies the axis and a list of integers which correspond to the <span>$i^{th}$</span> farthest   mode away from the COM (see note above about meaning of &quot;COM&quot;) for that axis. For example,    <code>selectedmodes=(z=[2])</code> would specify the axial stretch mode. These are the modes that will    be modeled in the chain.Note: <code>selectedmodes=(x=[],y=[],z=[1])</code>, <code>selectedmodes=(y=[],z=[1])</code>   and <code>selectedmodes=(;z=[1])</code> are all acceptable and equivalent.</li><li><code>N::Int=10</code>: Optionally specify the Hilbert space dimension for each normal mode.</li></ul><p><strong>derived fields</strong></p><ul><li><code>ionpositions::Vector{&lt;:Real}</code>: The relative positions of the ions in meters.  </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/iontraps.jl#L40-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.VibrationalMode" href="#IonSim.VibrationalMode"><code>IonSim.VibrationalMode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VibrationalMode(
        ν::Real, modestructure::Vector{Real}, δν::Union{Function,Real}=0.; N::Int=10,
        axis::NamedTuple{(:x,:y,:z)}=ẑ
    )</code></pre><p><strong>user-defined fields</strong></p><ul><li><code>ν::Real</code>: frequency [Hz]</li><li><code>modestructure::Vector{Real}</code>: The normalized eigenvector describing the collective motion        of the ions belonging to this mode.</li><li><code>δν::Union{Function,Real}</code>: Either a function describing time-dependent fluctuations of <code>ν</code>       or a real number which will be converted to the constant function <code>t -&gt; δν</code>.</li><li><code>N::Int</code>: Highest level included in the Hilbert space.</li><li><code>axis::NamedTuple{(:x,:y,:z)}</code>: The axis of symmetry for the vibration. This must lie along       one of the basis vectors <code>x̂</code>, <code>ŷ</code> or <code>ẑ</code>.</li></ul><p><strong>derived fields</strong></p><ul><li><code>shape::Vector{Int}</code>: Indicates dimension of used Hilbert space (<code>=[N+1]</code>).</li><li><code>_cnst_δν::Bool</code>: A Boolean flag signifying whether or not <code>δν</code> is a constant function.</li></ul><p>Note: the iᵗʰ Fock state (|i⟩) can be obtained by indexing as <code>v=VibrationalMode(...); v[i]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/vibrationalmodes.jl#L14-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.LinearChain_fromyaml-Tuple{}" href="#IonSim.LinearChain_fromyaml-Tuple{}"><code>IonSim.LinearChain_fromyaml</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LinearChain_fromyaml(ions::Vector{&lt;:Ion}, yaml::String; N::Int=10)</code></pre><p>Load normal mode structure from the specified <code>yaml</code> file. It&#39;s up to the user to enforce physicality.</p><pre><code class="nohighlight hljs">x:
  - frequency: 1e6
    mode: [0.1, 0.5, 0.3, 0.8]
  - frequency: 2e6
    mode: [0.3, 0.6, 0.5, 3]
y:
  - frequency: 8e6
    mode: [1, 1, 1, 1]
ionpositions: [-1, -0.5, -0.25, 5]</code></pre><p>It is up to the user to enforce the physicality of this structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/iontraps.jl#L123-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.axis-Tuple{VibrationalMode}" href="#IonSim.axis-Tuple{VibrationalMode}"><code>IonSim.axis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">axis(mode::VibrationalMode)</code></pre><p>Returns <code>mode.axis</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/vibrationalmodes.jl#L89-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.basis-Tuple{Chamber}" href="#IonSim.basis-Tuple{Chamber}"><code>IonSim.basis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">basis(chamber::Chamber)</code></pre><p>Returns the composite basis describing the Hilbert space for <code>chamber</code>. This is the same as basis(iontrap(chain)).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/chambers.jl#L246-L251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.basis-Tuple{LinearChain}" href="#IonSim.basis-Tuple{LinearChain}"><code>IonSim.basis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">basis(chain::LinearChain)::CompositeBasis</code></pre><p>Returns the composite basis describing the Hilbert space for <code>chain</code>.</p><p>Order is <span>$ion₁ ⊗ ion₂ ⊗ ... ⊗ ion_N ⊗ mode₁ ⊗ mode₂ ⊗ ... ⊗ mode_N$</span>, where the ion bases are ordered according to the order in <code>ions(chain)</code> and the vibrational modes are ordered according to the order in <code>[xmodes(chain), ymodes(chain), zmodes(chain)]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/iontraps.jl#L641-L649">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.bfield!-Tuple{Chamber, Real}" href="#IonSim.bfield!-Tuple{Chamber, Real}"><code>IonSim.bfield!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bfield!(chamber::Chamber, B::Real)</code></pre><p>Sets <code>chamber.B</code> to <code>B</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/chambers.jl#L189-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.bfield-Tuple{Chamber, Ion}" href="#IonSim.bfield-Tuple{Chamber, Ion}"><code>IonSim.bfield</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bfield(chamber::Chamber, ion)</code></pre><p>Retuns the value of the magnetic field in <code>T</code> at the location of <code>ion</code>, including both the trap&#39;s overall B-field and its B-field gradient. <code>ion</code> may be either an Ion or an Int indicating the desired ion&#39;s index within <code>chamber</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/chambers.jl#L563-L567">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.bfield-Tuple{Chamber}" href="#IonSim.bfield-Tuple{Chamber}"><code>IonSim.bfield</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bfield(chamber::Chamber)</code></pre><p>Returns the magnitude of the (average) magnetic field in <code>chamber</code>, <code>chamber.B</code>,in T.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/chambers.jl#L146-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.bfield_fluctuation!-Tuple{Chamber, Function}" href="#IonSim.bfield_fluctuation!-Tuple{Chamber, Function}"><code>IonSim.bfield_fluctuation!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bfield_fluctuation!(chamber::Chamber, δB::Function)</code></pre><p>Sets <code>chamber.δB</code> to <code>δB</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/chambers.jl#L215-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.bfield_fluctuation!-Tuple{Chamber, Real}" href="#IonSim.bfield_fluctuation!-Tuple{Chamber, Real}"><code>IonSim.bfield_fluctuation!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bfield_fluctuation!(chamber::Chamber, δB::Real)</code></pre><p>Sets <code>chamber.δB</code> to a constant function <code>t -&gt; δB</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/chambers.jl#L223-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.bfield_fluctuation-Tuple{Chamber}" href="#IonSim.bfield_fluctuation-Tuple{Chamber}"><code>IonSim.bfield_fluctuation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bfield_fluctuation(chamber::Chamber)::Function</code></pre><p>Returns the small magnetic field fluctuation <code>chamber.δB</code> in T as a function of time in s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/chambers.jl#L164-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.bfield_unitvector!-Tuple{Chamber, NamedTuple{(:x, :y, :z), T} where T&lt;:Tuple}" href="#IonSim.bfield_unitvector!-Tuple{Chamber, NamedTuple{(:x, :y, :z), T} where T&lt;:Tuple}"><code>IonSim.bfield_unitvector!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bfield_unitvector!(chamber::Chamber, Bhat::NamedTuple)</code></pre><p>Sets <code>chamber.Bhat</code> to <code>Bhat</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/chambers.jl#L197-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.bfield_unitvector-Tuple{Chamber}" href="#IonSim.bfield_unitvector-Tuple{Chamber}"><code>IonSim.bfield_unitvector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bfield_unitvector(chamber::Chamber)::NamedTuple{:x, :y, :z}</code></pre><p>Returns the direction of the magnetic field inside <code>chamber</code>, <code>chamber.Bhat</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/chambers.jl#L152-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.bgradient!-Tuple{Chamber, Real}" href="#IonSim.bgradient!-Tuple{Chamber, Real}"><code>IonSim.bgradient!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bgradient!(chamber::Chamber, ∇B::Real)</code></pre><p>Sets <code>chamber.∇B</code> to <code>∇B</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/chambers.jl#L207-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.bgradient!-Tuple{Chamber, Tuple{Int64, Int64}, Tuple, Real}" href="#IonSim.bgradient!-Tuple{Chamber, Tuple{Int64, Int64}, Tuple, Real}"><code>IonSim.bgradient!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bgradient!(
        T::Chamber, ion_indxs::Tuple{Int,Int}, transition::Tuple, d::Real
    )</code></pre><p>Sets the Bfield gradient in place to achieve a detuning <code>d</code> between the <code>transition</code> of two ions, which are assumed to be of the same species. <code>ion_indxs</code> refer to the ordering of the ions in the chain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/chambers.jl#L702-L709">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.bgradient-Tuple{Chamber}" href="#IonSim.bgradient-Tuple{Chamber}"><code>IonSim.bgradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bgradient(chamber::Chamber)</code></pre><p>Returns the gradient of the magnetic field inside <code>chamber</code>, <code>chamber.∇B</code>, in T/m.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/chambers.jl#L158-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.charge-Tuple{Ion}" href="#IonSim.charge-Tuple{Ion}"><code>IonSim.charge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">charge(ion::Ion)</code></pre><p>Returns the charge of <code>ion</code>in C.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/ions.jl#L125-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.clearsublevelalias!-Tuple{Ion, Tuple{String, Real}}" href="#IonSim.clearsublevelalias!-Tuple{Ion, Tuple{String, Real}}"><code>IonSim.clearsublevelalias!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">clearsublevelalias!(I::Ion, sublevel)</code></pre><p>Erases the assignment of an alias to <code>sublevel</code> of Ion <code>I</code>. Accepts either the full sublevel <code>Tuple{String,Real}</code> or its alias <code>String</code>. Also accepts a vector of sublevels to clear multiple alias assignments in a single call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/ions.jl#L176-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.clearsublevelalias!-Tuple{Ion}" href="#IonSim.clearsublevelalias!-Tuple{Ion}"><code>IonSim.clearsublevelalias!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">clearsublevelalias!(I::Ion)</code></pre><p>Erases the assignment of all sublevel aliases of Ion <code>I</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/ions.jl#L191-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.coherentstate-Tuple{VibrationalMode, Number}" href="#IonSim.coherentstate-Tuple{VibrationalMode, Number}"><code>IonSim.coherentstate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">coherentstate(v::VibrationalMode, α::Number)</code></pre><p>Returns a coherent state on <code>v</code> with complex amplitude <span>$α$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/operators.jl#L98-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.comfrequencies-Tuple{LinearChain}" href="#IonSim.comfrequencies-Tuple{LinearChain}"><code>IonSim.comfrequencies</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">comfrequencies(chain::LinearChain)</code></pre><p>Returns <code>chain.comfrequencies</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/iontraps.jl#L588-L591">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.create-Tuple{VibrationalMode}" href="#IonSim.create-Tuple{VibrationalMode}"><code>IonSim.create</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create(v::VibrationalMode)</code></pre><p>returns the creation operator for <code>v</code> such that: <code>create(v) * v[i] = √(i+1) * v[i+1]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/operators.jl#L21-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.destroy-Tuple{VibrationalMode}" href="#IonSim.destroy-Tuple{VibrationalMode}"><code>IonSim.destroy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">destroy(v::VibrationalMode)</code></pre><p>Returns the destruction operator for <code>v</code> such that: <code>destroy(v) * v[i] = √i * v[i-1]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/operators.jl#L27-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.detuning!-Tuple{Laser, Real}" href="#IonSim.detuning!-Tuple{Laser, Real}"><code>IonSim.detuning!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wavelength!(laser::Laser, Δ::Real)</code></pre><p>Sets the detuning of <code>laser</code> to <code>Δ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/lasers.jl#L146-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.detuning-Tuple{Laser}" href="#IonSim.detuning-Tuple{Laser}"><code>IonSim.detuning</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">detuning(laser::Laser)::Real</code></pre><p>Returns the laser&#39;s detuning <code>laser.Δ</code> (in Hz)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/lasers.jl#L92-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.efield-Tuple{Laser}" href="#IonSim.efield-Tuple{Laser}"><code>IonSim.efield</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">efield(laser::Laser)::Function</code></pre><p>Returns the electric field amplitude (in V/m) of <code>laser</code> as a function of time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/lasers.jl#L217-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.efield-Tuple{Real}" href="#IonSim.efield-Tuple{Real}"><code>IonSim.efield</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">efield(I::Real)::Real</code></pre><p>Returns the electric field (in V/m) corresponding to a light intensity of <code>I</code> (in W/m²) <code>E = √(2I/(cϵ₀))</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/lasers.jl#L210-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.einsteinA-Tuple{Ion, Tuple{String, String}}" href="#IonSim.einsteinA-Tuple{Ion, Tuple{String, String}}"><code>IonSim.einsteinA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">einsteinA(I::Ion, leveltransition::Tuple)</code></pre><p>Returns Einstein A coefficient corresponding to the transition <code>leveltransition[1] -&gt; leveltransition[2]</code>. The first level must be the lower level and the second must be the upper level.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/ions.jl#L515-L518">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.energy-Tuple{Ion, String}" href="#IonSim.energy-Tuple{Ion, String}"><code>IonSim.energy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">energy(I::Ion, level::String)</code></pre><p>Returns the energy of <code>level</code> of <code>I</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/ions.jl#L424-L428">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.energy-Tuple{Ion, Tuple{String, Real}}" href="#IonSim.energy-Tuple{Ion, Tuple{String, Real}}"><code>IonSim.energy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">energy(I::Ion, sublevel; B=0, ignore_manualshift=false)</code></pre><p>Returns energy of <code>sublevel</code> of <code>I</code>. A Zeeman shift may be included by setting the value of the magnetic field <code>B</code>. The manual shift may be omitted by setting <code>ignore_manualshift=true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/ions.jl#L413-L416">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.frequency!-Tuple{VibrationalMode, Real}" href="#IonSim.frequency!-Tuple{VibrationalMode, Real}"><code>IonSim.frequency!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">frequency!(mode::VibrationalMode, ν::Real)</code></pre><p>Sets <code>mode.ν</code> to <code>ν</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/vibrationalmodes.jl#L99-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.frequency-Tuple{VibrationalMode}" href="#IonSim.frequency-Tuple{VibrationalMode}"><code>IonSim.frequency</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">frequency(mode::VibrationalMode)</code></pre><p>Returns <code>mode.ν</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/vibrationalmodes.jl#L59-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.frequency_fluctuation!-Tuple{VibrationalMode, Function}" href="#IonSim.frequency_fluctuation!-Tuple{VibrationalMode, Function}"><code>IonSim.frequency_fluctuation!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">frequency_fluctuation!(mode::VibrationalMode, δν::Function)</code></pre><p>Sets <code>mode.δν</code> to <code>δν</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/vibrationalmodes.jl#L107-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.frequency_fluctuation!-Tuple{VibrationalMode, Real}" href="#IonSim.frequency_fluctuation!-Tuple{VibrationalMode, Real}"><code>IonSim.frequency_fluctuation!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">frequency_fluctuation!(mode::VibrationalMode, δν::Real)</code></pre><p>Sets <code>mode.δν</code> to a constant function <code>t -&gt; δν</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/vibrationalmodes.jl#L115-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.frequency_fluctuation-Tuple{VibrationalMode}" href="#IonSim.frequency_fluctuation-Tuple{VibrationalMode}"><code>IonSim.frequency_fluctuation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">frequency_fluctuation(mode::VibrationalMode)</code></pre><p>Returns <code>mode.δν</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/vibrationalmodes.jl#L71-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.full_normal_mode_description-Tuple{Any, NamedTuple{(:x, :y, :z), T} where T&lt;:Tuple}" href="#IonSim.full_normal_mode_description-Tuple{Any, NamedTuple{(:x, :y, :z), T} where T&lt;:Tuple}"><code>IonSim.full_normal_mode_description</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">full_normal_mode_description(ions, comfreqs::NamedTuple{(:x, :y, :z)})</code></pre><p>Same thing but with an iterable list of <code>ions</code> and <code>NamedTuple</code> of COM frequencies explicitly given.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/iontraps.jl#L545-L550">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.full_normal_mode_description-Tuple{LinearChain}" href="#IonSim.full_normal_mode_description-Tuple{LinearChain}"><code>IonSim.full_normal_mode_description</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">full_normal_mode_description(chain::LinearChain)</code></pre><p>For each axis, this contains an array of tuples where the first element is a vibrational frequency [Hz] and the second element is a vector describing the participation of each ion at that vibrational frequency (i.e. the normal mode eigenvector corresponding to that  eigenfrequency).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/iontraps.jl#L534-L541">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.full_normal_mode_description-Tuple{Vector{var&quot;#s139&quot;} where var&quot;#s139&quot;&lt;:Real, Vector{var&quot;#s138&quot;} where var&quot;#s138&quot;&lt;:Int64, NamedTuple{(:x, :y, :z), T} where T&lt;:Tuple}" href="#IonSim.full_normal_mode_description-Tuple{Vector{var&quot;#s139&quot;} where var&quot;#s139&quot;&lt;:Real, Vector{var&quot;#s138&quot;} where var&quot;#s138&quot;&lt;:Int64, NamedTuple{(:x, :y, :z), T} where T&lt;:Tuple}"><code>IonSim.full_normal_mode_description</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function full_normal_mode_description(
    M::Vector{&lt;:Real}, Q::Vector{&lt;:Int}, comfreqs::NamedTuple{(:x, :y, :z)}
)</code></pre><p>Same thing but explicitly provide the masses <code>M</code> and charges <code>Q</code> of the ions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/iontraps.jl#L567-L572">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.globalbeam!-Tuple{Laser, Chamber}" href="#IonSim.globalbeam!-Tuple{Laser, Chamber}"><code>IonSim.globalbeam!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">globalbeam!(laser, chamber::Chamber)</code></pre><p>Set <code>laser</code> to shine with full intensity on all ions in <code>Chamber</code>. <code>laser</code> may be either a Laser or an Int indicating the desired laser&#39;s index within <code>chamber</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/chambers.jl#L316-L320">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.groundstate-Tuple{VibrationalMode}" href="#IonSim.groundstate-Tuple{VibrationalMode}"><code>IonSim.groundstate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">groundstate(obj)</code></pre><p>If obj is a <code>VibrationalMode</code>, returns the N=0 ket of that mode. If obj is a Vector of <code>VibrationalMode</code>, returns a tensor product <code>mode1[0] ⊗ mode2[0] ⊗ ...</code> in the same order given. If obj is a <code>LinearChain</code>, returns the full ground state of the motional degrees of freedom as a tensor product.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/chambers.jl#L305-L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.hamiltonian-Tuple{Chamber}" href="#IonSim.hamiltonian-Tuple{Chamber}"><code>IonSim.hamiltonian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hamiltonian(
        chamber::Chamber; timescale::Real=1, lamb_dicke_order::Union{Vector{Int},Int}=1,
        rwa_cutoff::Real=Inf, displacement=&quot;truncated&quot;, time_dependent_eta=false
    )</code></pre><p>Constructs the Hamiltonian for <code>chamber</code> as a function of time. Return type is a function <code>h(t::Real, ψ)</code> that, itself, returns a <code>QuantumOptics.SparseOperator</code>.</p><p><strong>args</strong></p><ul><li><p><code>timescale</code>: e.g. a value of 1e-6 will take time to be in μs</p></li><li><p><code>lamb_dicke_order</code>: Only consider terms that change the phonon number by up to this value.   If this is an <code>Int</code>, then the cutoff is applied to all modes. If this is a <code>Vector{Int}</code>,   then <code>lamb_dicke_order[i]</code> is applied to the iᵗʰ mode, according to the order in   <code>basis(chamber)</code>.   Note: this isn&#39;t quite the same thing as the Lamb-Dicke approximation since setting   <code>lamb_dicke_order=1</code> will retain, for example, terms proportional to <span>$a^\dagger a$</span>.</p></li><li><p><code>rwa_cutoff</code>: drop terms in the Hamiltonian that oscillate faster than this cutoff.</p></li><li><p><code>displacement</code>: This can be either <code>&quot;truncated&quot;</code>(default) or <code>&quot;analytic&quot;</code>.</p><p>When an atom is irradiated, both the atom&#39;s energy and its momentum will generally be  affected. For an atom in a harmonic potential, the exchange of momentum can be modeled as  a displacement operation <span>$D(α=iηe^{-iνt}) = exp[αa^† - α^*a]$</span>, where <span>$η$</span> is the  Lamb-Dicke parameter, which can be described equivalently as either being proportional to  the square root of the ratio of the recoil frequency with the ground state energy of the  atom&#39;s motion or as the ratio of the spread of the ground state wavefunction to the  wavelength of the laser.</p><p>When <code>&quot;truncated&quot;</code> is selected, the matrix elements of <span>$D(α)$</span> are computed by  constructing <span>$α^* a, αa^†$</span> in a truncated basis (according to the dimension specified in  your model) and then exponentiating their difference. This has the advantage, amongst  other things, of guaranting unitarity.</p><p>If <code>&quot;analytic&quot;</code> is selected, then the matrix elements are computed assuming an infinite-  dimensional Hilbert space.</p><p>For small displacements (<span>$η ≪ N$</span>, where <span>$N$</span> is the dimension of the motion&#39;s Hilbert  space), both of these methods will be good approximations.</p></li><li><p><code>time_dependent_eta::Bool</code>: In addition to impacting the vibrational subspace directly, a  change in the trap frequency, <span>$δν$</span>, will also change the Lamb-Dicke parameter. Since  typically <span>$δν≪ν$</span>, this effect will be small <span>$η ≈ η₀(1 + δν/2ν)$</span> and doesn&#39;t warrant  the additional computational resources needed to calculate and update it in time. In this  case, we can set <code>time_dependent_eta=false</code> (default), which will set <span>$η(t) = η₀$</span>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/hamiltonians.jl#L8-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.intensity!-Tuple{Laser, Function}" href="#IonSim.intensity!-Tuple{Laser, Function}"><code>IonSim.intensity!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intensity(laser::Laser, I::Union{Function,Real})</code></pre><p>Sets the intensity of <code>laser</code> to <code>I</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/lasers.jl#L135-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.intensity-Tuple{Laser}" href="#IonSim.intensity-Tuple{Laser}"><code>IonSim.intensity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intensity(laser::Laser)::Function</code></pre><p>Returns the laser&#39;s intensity <code>laser.I</code> (in W/m²) as a function of time</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/lasers.jl#L86-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.intensity_from_pitime!-Tuple{Laser, Real, Ion, Tuple, NamedTuple{(:x, :y, :z), T} where T&lt;:Tuple}" href="#IonSim.intensity_from_pitime!-Tuple{Laser, Real, Ion, Tuple, NamedTuple{(:x, :y, :z), T} where T&lt;:Tuple}"><code>IonSim.intensity_from_pitime!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intensity_from_pitime!(
    laser::Laser, pi_time::Real, ion::Ion, transition::Tuple,
    Bhat::NamedTuple{(:x,:y,:z)}
)
intensity_from_pitime!(
    laser, pi_time::Real, ion, transition::Tuple, chamber::Chamber
)</code></pre><p>Same as <code>intensity_from_pitime</code>, but updates <code>laser[:I]</code> in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/chambers.jl#L403-L412">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.intensity_from_pitime-Tuple{Laser, Real, Ion, Tuple, Chamber}" href="#IonSim.intensity_from_pitime-Tuple{Laser, Real, Ion, Tuple, Chamber}"><code>IonSim.intensity_from_pitime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intensity_from_pitime(
    laser, pi_time::Real, ion, transition::Tuple, chamber::Chamber
    )</code></pre><p>Compute the intensity needed to get a certain <code>pi_time</code> with a certain resonant <code>laser</code>-<code>ion</code> <code>transition</code> within <code>chamber</code>, which defines the magnetic field direction. <code>laser</code> may be either a Laser or an Int indicating the desired laser&#39;s index within <code>chamber</code>. <code>ion</code> may be either an Ion or an Int indicating the desired ion&#39;s index within <code>chamber</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/chambers.jl#L362-L370">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.intensity_from_pitime-Tuple{Laser, Real, Ion, Tuple, NamedTuple{(:x, :y, :z), T} where T&lt;:Tuple}" href="#IonSim.intensity_from_pitime-Tuple{Laser, Real, Ion, Tuple, NamedTuple{(:x, :y, :z), T} where T&lt;:Tuple}"><code>IonSim.intensity_from_pitime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intensity_from_pitime(
    laser::Laser, pi_time::Real, ion::Ion, transition::Tuple,
    Bhat::NamedTuple{(:x,:y,:z)}
)</code></pre><p>Compute the intensity needed to get a certain <code>pi_time</code> with a certain resonant <code>laser</code>-<code>ion</code> <code>transition</code>, in the presence of a magnetic field pointing in the direction <code>Bhat</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/chambers.jl#L331-L338">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.intensity_from_rabifrequency!-Tuple{Laser, Real, Ion, Tuple, NamedTuple{(:x, :y, :z), T} where T&lt;:Tuple}" href="#IonSim.intensity_from_rabifrequency!-Tuple{Laser, Real, Ion, Tuple, NamedTuple{(:x, :y, :z), T} where T&lt;:Tuple}"><code>IonSim.intensity_from_rabifrequency!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intensity_from_rabifrequency!(
    laser::Laser, rabi_frequency::Real, ion::Ion, transition::Tuple,
    Bhat::NamedTuple{(:x,:y,:z)}
)
intensity_from_rabifrequency!(
    laser, rabi_frequency::Real, ion, transition::Tuple, chamber::Chamber
)</code></pre><p>Same as <code>intensity_from_rabifrequency!</code>, but updates <code>laser[:I]</code> in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/chambers.jl#L510-L519">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.intensity_from_rabifrequency-Tuple{Laser, Real, Ion, Tuple, Chamber}" href="#IonSim.intensity_from_rabifrequency-Tuple{Laser, Real, Ion, Tuple, Chamber}"><code>IonSim.intensity_from_rabifrequency</code></a> — <span class="docstring-category">Method</span></header><section><div><p>intensity<em>from</em>rabifrequency(         laser, rabi<em>frequency::Real, ion, transition::Tuple, chamber::Chamber         ) Compute the intensity needed to get a certain `rabi</em>frequency<code>with a certain resonant</code>laser<code>-</code>ion<code></code>transition<code>within</code>chamber<code>, which defines the magnetic field direction.</code>laser<code>may be either a Laser or an Int indicating the desired laser&#39;s index within</code>chamber<code>.</code>ion<code>may be either an Ion or an Int indicating the desired ion&#39;s index within</code>chamber<code>.</code>laser<code>and</code>ion` must either both be indices or both their respective Structs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/chambers.jl#L468-L477">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.intensity_from_rabifrequency-Tuple{Laser, Real, Ion, Tuple, NamedTuple{(:x, :y, :z), T} where T&lt;:Tuple}" href="#IonSim.intensity_from_rabifrequency-Tuple{Laser, Real, Ion, Tuple, NamedTuple{(:x, :y, :z), T} where T&lt;:Tuple}"><code>IonSim.intensity_from_rabifrequency</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intensity_from_rabifrequency(
    laser::Laser, rabi_frequency::Real, ion::Ion, transition::Tuple,
    Bhat::NamedTuple{(:x,:y,:z)}
)</code></pre><p>Compute the intensity needed to get a certain <code>rabi_frequency</code> with a certain resonant <code>laser</code>-<code>ion</code> <code>transition</code>, in the presence of a magnetic field pointing in the direction <code>Bhat</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/chambers.jl#L450-L457">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.ionnumber-Tuple{Ion}" href="#IonSim.ionnumber-Tuple{Ion}"><code>IonSim.ionnumber</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ionnumber(ion::Ion)</code></pre><p>Returns <code>ion</code>&#39;s number in its IonTrap <code>ion.ionnumber</code> If <code>ion</code> has not been added to an IonTrap, returns <code>missing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/ions.jl#L87-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.ionposition-Tuple{Ion}" href="#IonSim.ionposition-Tuple{Ion}"><code>IonSim.ionposition</code></a> — <span class="docstring-category">Method</span></header><section><div><p>ionposition(ion::Ion) Returns <code>ion</code>&#39;s position in its IonTrap, <code>ion.ionposition</code> in m. If <code>ion</code> has not been added to an IonTrap, returns <code>missing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/ions.jl#L101-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.ionpositions-Tuple{Any}" href="#IonSim.ionpositions-Tuple{Any}"><code>IonSim.ionpositions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ionpositions(chain::LinearChain)</code></pre><p>Returns the positions of the ions in <code>chain</code> in meters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/iontraps.jl#L703-L706">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.ionprojector-Tuple{IonTrap, Vararg{Union{Int64, String, Tuple{String, Real}}, N} where N}" href="#IonSim.ionprojector-Tuple{IonTrap, Vararg{Union{Int64, String, Tuple{String, Real}}, N} where N}"><code>IonSim.ionprojector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ionprojector(obj, sublevels...; only_ions=false)</code></pre><p>If <code>obj&lt;:IonTrap</code> this will return <span>$|ψ₁⟩⟨ψ₁|⊗...⊗|ψ\_N⟩⟨ψ\_N|⊗𝟙$</span> where <span>$|ψᵢ⟩$</span> = <code>obj.ions[i][sublevels[i]]</code> and the identity operator <span>$𝟙$</span> is over all of the COM modes considered in <code>obj</code>.</p><p>If <code>only_ions=true</code>, then the projector is defined only over the ion subspace.</p><p>If instead <code>obj&lt;:Chamber</code>, then this is the same as <code>obj = Chamber.iontrap</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/operators.jl#L186-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.ions-Tuple{Chamber}" href="#IonSim.ions-Tuple{Chamber}"><code>IonSim.ions</code></a> — <span class="docstring-category">Method</span></header><section><div><p>&quot;     ions(T::Chamber) Returns a list of the ions in the <code>Chamber</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/chambers.jl#L269-L273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.ionstate-Tuple{Ion, Tuple{String, Real}}" href="#IonSim.ionstate-Tuple{Ion, Tuple{String, Real}}"><code>IonSim.ionstate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ionstate(ion::Ion, sublevel)</code></pre><p>Retuns the ket corresponding to the <code>Ion</code> being in state <span>$|sublevel⟩$</span>. Options: sublevel &lt;: Tuple{String,Real}: Specifies full sublevel name sublevel &lt;: String: Specifies sublevel alias sublevel &lt;: Int: Returns the <code>sublevel</code>th eigenstate</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/operators.jl#L144-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.ionstate-Tuple{IonTrap, Vector{T} where T}" href="#IonSim.ionstate-Tuple{IonTrap, Vector{T} where T}"><code>IonSim.ionstate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ionstate(object::Union{IonTrap, Chamber}, sublevels)</code></pre><p>If <code>N = length(ions(object))</code>, returns N-dimensional ket corresponding to the ions being in the state <span>$|sublevel₁⟩⊗|sublevel₂⟩⊗...⊗|sublevel\_N⟩$</span>.</p><p><code>sublevels</code> must be an length-<code>N</code> Vector, with each element specifying its corresponding ion&#39;s sublevel, using the same syntax as in <code>ionstate(ion::Ion, sublevel)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/operators.jl#L159-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.iontrap!-Tuple{Chamber, IonTrap}" href="#IonSim.iontrap!-Tuple{Chamber, IonTrap}"><code>IonSim.iontrap!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iontrap!(chamber::Chamber, iontrap::IonTrap)</code></pre><p>Sets <code>chamber.iontrap</code> to <code>iontrap</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/chambers.jl#L181-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.iontrap-Tuple{Chamber}" href="#IonSim.iontrap-Tuple{Chamber}"><code>IonSim.iontrap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iontrap(chamber::Chamber)</code></pre><p>Returns the IonTrap struct associated with <code>chamber</code>, <code>chamber.iontrap</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/chambers.jl#L140-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.lambdicke-Tuple{VibrationalMode, Ion, Laser}" href="#IonSim.lambdicke-Tuple{VibrationalMode, Ion, Laser}"><code>IonSim.lambdicke</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lambdicke(V::VibrationalMode, I::Ion, L::Laser)</code></pre><p>The Lamb-Dicke parameter:  <span>$|k|cos(\theta)\sqrt{\frac{\hbar}{2m\nu}}$</span>  for a given vibrational mode, ion and laser.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/chambers.jl#L749-L754">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.landegf" href="#IonSim.landegf"><code>IonSim.landegf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">landegf(l::Real, j::Real, f::Real, i::Real, s::Real=1//2)</code></pre><p>Landé g-factor of hyperfine energy level</p><p><strong>args</strong></p><ul><li><code>l</code>: orbital angular momentum quantum number</li><li><code>j</code>: electron total angular momentum quantum number</li><li><code>f</code>: total angular momentum quantum number</li><li><code>i</code>: nuclear spin angular momentum quantum number</li><li><code>s</code>: electronic spin angular momentum quantum number (defaults to 1/2)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/ions.jl#L344-L355">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.landegf-Tuple{Ion, String}" href="#IonSim.landegf-Tuple{Ion, String}"><code>IonSim.landegf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">landegf(I::Ion, level::String)</code></pre><p><code>landegf</code> for the quantum numbers of <code>level</code> in <code>I</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/ions.jl#L359-L363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.lasers!-Tuple{Chamber, Vector{Laser}}" href="#IonSim.lasers!-Tuple{Chamber, Vector{Laser}}"><code>IonSim.lasers!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lasers!(chamber::Chamber, lasers::Vector{Laser})</code></pre><p>Sets <code>chamber.lasers</code> to <code>lasers</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/chambers.jl#L232-L235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.lasers-Tuple{Chamber}" href="#IonSim.lasers-Tuple{Chamber}"><code>IonSim.lasers</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lasers(chamber::Chamber)::Vector{Laser}</code></pre><p>Returns Vector of Lasers inside <code>chamber</code>, <code>chamber.lasers</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/chambers.jl#L170-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.level-Tuple{Ion, Tuple{String, Real}}" href="#IonSim.level-Tuple{Ion, Tuple{String, Real}}"><code>IonSim.level</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">level(I::Ion, sublevel)</code></pre><p>Retuns the energy level of <code>I</code> corresponding to <code>sublevel</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/ions.jl#L268-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.levels-Tuple{Ion}" href="#IonSim.levels-Tuple{Ion}"><code>IonSim.levels</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">levels(I::Ion)</code></pre><p>Returns array of all energy levels of <code>I</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/ions.jl#L233-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.leveltransitions-Tuple{Ion}" href="#IonSim.leveltransitions-Tuple{Ion}"><code>IonSim.leveltransitions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">leveltransitions(I::Ion)</code></pre><p>Returns all allowed transitions between levels of <code>I</code> as a vector of <code>Tuple{String,String}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/ions.jl#L470-L474">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.lifetime-Tuple{Ion, String}" href="#IonSim.lifetime-Tuple{Ion, String}"><code>IonSim.lifetime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lifetime(I::Ion, level::String)</code></pre><p>Computes lifetime of <code>level</code> by summing the transition rates out of <code>level</code>. The sum is taken   over all levels that the species may have, rather than the levels present in the instance <code>I</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/ions.jl#L535-L540">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.manualshift!-Tuple{Ion, Dict}" href="#IonSim.manualshift!-Tuple{Ion, Dict}"><code>IonSim.manualshift!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">manualshift!(I::Ion, manualshift_dict::Dict)</code></pre><p>Applies <code>manualshift(I, sublevel, shift)</code> to all pairs <code>sublevel =&gt; shift</code> of the Dict <code>manual_shift_dict</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/ions.jl#L209-L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.manualshift!-Tuple{Ion, Tuple{String, Real}, Real}" href="#IonSim.manualshift!-Tuple{Ion, Tuple{String, Real}, Real}"><code>IonSim.manualshift!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">manualshift!(I::Ion, sublevel, shift::Real)</code></pre><p>Applies a manual shift <code>shift</code> to the chosen <code>sublevel</code> of <code>I</code> (overwriting any previously assigned manual shift).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/ions.jl#L199-L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.manualshift-Tuple{Ion, Tuple{String, Real}}" href="#IonSim.manualshift-Tuple{Ion, Tuple{String, Real}}"><code>IonSim.manualshift</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">manualshift(I::Ion, sublevel)</code></pre><p>Returns the assigned manual shift of <code>sublevel</code> of Ion <code>I</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/ions.jl#L373-L376">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.manualshift-Tuple{Ion}" href="#IonSim.manualshift-Tuple{Ion}"><code>IonSim.manualshift</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">manualshift(ion::Ion)</code></pre><p>Returns the Dict of manualshift for <code>ion</code>&#39;s energy levels <code>ion.manualshift</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/ions.jl#L81-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.mass-Tuple{Ion}" href="#IonSim.mass-Tuple{Ion}"><code>IonSim.mass</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mass(ion::Ion)</code></pre><p>Returns the mass of <code>ion</code> in kg.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/ions.jl#L119-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.matrixelement" href="#IonSim.matrixelement"><code>IonSim.matrixelement</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">matrixelement(ion::Ion, transition::Tuple, I::Real, ϵhat::NamedTuple, khat::NamedTuple, Bhat::NamedTuple=(;z=1))</code></pre><p>Computes the matrix elements (units of Hz) between two energy sublevels <strong>args</strong></p><ul><li><code>ion</code>: Ion undergoing transition</li><li><code>transition</code>: Tuple of sublevels (full names or aliases) between which the transition is being calculated. Must be formatted such that <code>energy(transition[2]) &gt; energy(transition[1])</code></li><li><code>I</code>: Intensity of the driving field</li><li><code>ϵhat</code>: Unit vector of light polarization</li><li><code>khat</code>: Unit vector of light wavevector</li><li><code>Bhat</code>: Unit vector of magnetic field</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/ions.jl#L558-L568">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.matrixelement-Tuple{Ion, Tuple, Laser, Chamber, Real}" href="#IonSim.matrixelement-Tuple{Ion, Tuple, Laser, Chamber, Real}"><code>IonSim.matrixelement</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrixelement(ion, transition::Tuple, laser, chamber::Chamber, time::Real)</code></pre><p>Calls <code>matrixelement(ion, transition, I, ϵhat, khat, Bhat)</code> with <code>I</code>, <code>ϵhat</code>, and <code>khat</code> evaluated for <code>laser</code> at time <code>time</code>, and <code>Bhat</code> evaluated for <code>chamber</code>.</p><p><code>ion</code> may be either an Ion or an Int indicating the desired ion&#39;s index within <code>chamber</code>. <code>laser</code> may be either a Laser or an Int indicating the desired laser&#39;s index within <code>chamber</code>. <code>ion</code> and <code>laser</code> must either both be indices or both their respective Structs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/chambers.jl#L671-L679">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.modecutoff!-Tuple{Chamber, Int64}" href="#IonSim.modecutoff!-Tuple{Chamber, Int64}"><code>IonSim.modecutoff!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">modecutoff!(T::Chamber, N::Int)</code></pre><p>Sets the upper bound of the Hilbert space of all <code>VibrationalMode</code>s in the <code>IonTrap</code> of <code>T</code> to be the Fock state <code>N</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/chambers.jl#L297-L300">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.modecutoff!-Tuple{LinearChain, Int64}" href="#IonSim.modecutoff!-Tuple{LinearChain, Int64}"><code>IonSim.modecutoff!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">modecutoff!(lc::LinearChain, N::Int)</code></pre><p>Sets the upper bound of the Hilbert space of all <code>VibrationalMode</code>s in <code>lc</code> to be the Fock  state <code>N</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/iontraps.jl#L630-L634">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.modecutoff!-Tuple{VibrationalMode, Int64}" href="#IonSim.modecutoff!-Tuple{VibrationalMode, Int64}"><code>IonSim.modecutoff!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">modecutoff!(mode::VibrationalMode, N::Int)</code></pre><p>Sets the upper bound of the Hilbert space of <code>mode</code> to be the Fock state <code>N</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/vibrationalmodes.jl#L124-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.modecutoff-Tuple{VibrationalMode}" href="#IonSim.modecutoff-Tuple{VibrationalMode}"><code>IonSim.modecutoff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">modecutoff</code></pre><p>Returns <code>mode.N</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/vibrationalmodes.jl#L77-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.modes-Tuple{Chamber}" href="#IonSim.modes-Tuple{Chamber}"><code>IonSim.modes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">modes(T::Chamber)</code></pre><p>Returns modes(iontrap(T))</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/chambers.jl#L276-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.modes-Tuple{LinearChain}" href="#IonSim.modes-Tuple{LinearChain}"><code>IonSim.modes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">modes(lc::LinearChain)</code></pre><p>Returns an array of all of the selected <code>VibrationalModes</code> in the <code>LinearChain</code>. The order is <code>[lc.x..., lc.y..., lc.z...]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/iontraps.jl#L600-L604">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.modestructure-Tuple{VibrationalMode}" href="#IonSim.modestructure-Tuple{VibrationalMode}"><code>IonSim.modestructure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">modestructure(mode::VibrationalMode)</code></pre><p>Returns <code>mode.modestructure</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/vibrationalmodes.jl#L65-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.nuclearspin-Tuple{Ion}" href="#IonSim.nuclearspin-Tuple{Ion}"><code>IonSim.nuclearspin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nuclearspin(ion::Ion)</code></pre><p>Returns the nuclear spin of <code>ion</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/ions.jl#L131-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.number-Tuple{VibrationalMode}" href="#IonSim.number-Tuple{VibrationalMode}"><code>IonSim.number</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">number(v::VibrationalMode)</code></pre><p>Returns the number operator for <code>v</code> such that:  <code>number(v) * v[i] = i * v[i]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/operators.jl#L33-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.phase!-Tuple{Laser, Function}" href="#IonSim.phase!-Tuple{Laser, Function}"><code>IonSim.phase!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">phase!(laser::Laser, ϕ::Union{Function,Real})</code></pre><p>Sets the phase of <code>laser</code> to <code>ϕ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/lasers.jl#L180-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.phase-Tuple{Laser}" href="#IonSim.phase-Tuple{Laser}"><code>IonSim.phase</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">phase(laser::Laser)::Function</code></pre><p>Returns the laser&#39;s phase <code>laser.ϕ</code> in (in radians) as a function of time</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/lasers.jl#L110-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.pointing!-Tuple{Laser, Array{Tuple{T1, T2}, 1} where {T2&lt;:Real, T1&lt;:Int64}}" href="#IonSim.pointing!-Tuple{Laser, Array{Tuple{T1, T2}, 1} where {T2&lt;:Real, T1&lt;:Int64}}"><code>IonSim.pointing!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pointing!(laser::Laser, p::Vector{Tuple{T1, T2}} where T1&lt;:Int where T2&lt;:Real)</code></pre><p>Sets the pointing of <code>laser</code> with <code>p</code>. <code>length(p)</code> should be equal to the number of ions in the <code>Chamber</code> containing <code>laser</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/lasers.jl#L191-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.pointing-Tuple{Laser}" href="#IonSim.pointing-Tuple{Laser}"><code>IonSim.pointing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pointing(laser::Laser)::Vector</code></pre><p>Return&#39;s the laser&#39;s pointing information <code>laser.pointing</code> if <code>laser</code> has been added to a <code>Chamber</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/lasers.jl#L116-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.polarization!-Tuple{Laser, NamedTuple{(:x, :y, :z), T} where T&lt;:Tuple}" href="#IonSim.polarization!-Tuple{Laser, NamedTuple{(:x, :y, :z), T} where T&lt;:Tuple}"><code>IonSim.polarization!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">polarization!(laser::Laser, ϵ::ReNamedTuple{(:x, :y, :z)})</code></pre><p>Sets the polarization of <code>laser</code> to <code>ϵ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/lasers.jl#L154-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.polarization-Tuple{Laser}" href="#IonSim.polarization-Tuple{Laser}"><code>IonSim.polarization</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">polarization(laser::Laser)::NamedTuple{(:x, :y, :z)}</code></pre><p>Returns the laser&#39;s polarization unit vector <code>laser.ϵ</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/lasers.jl#L98-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.quantumnumbers-Tuple{Ion, Tuple{String, Real}}" href="#IonSim.quantumnumbers-Tuple{Ion, Tuple{String, Real}}"><code>IonSim.quantumnumbers</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">quantumnumbers(I::Ion, level::String)
quantumnumbers(I::Ion, sublevel)</code></pre><p>Returns the quantum numbers of an energy level or sublevel of <code>I</code> as a <code>NamedTuple</code>. If second argument is a level, returns <code>(:n, :i, :s, :l, :j, :f)</code> If second argument is a sublevel, returns <code>(:n, :i, :s, :l, :j, :f, :m)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/ions.jl#L287-L294">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.selectedmodes-Tuple{LinearChain}" href="#IonSim.selectedmodes-Tuple{LinearChain}"><code>IonSim.selectedmodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">selectedmodes(chain::LinearChain)</code></pre><p>Returns <code>chain.selectedmodes</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/iontraps.jl#L594-L597">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.shape-Tuple{Ion}" href="#IonSim.shape-Tuple{Ion}"><code>IonSim.shape</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shape(ion::Ion)</code></pre><p>Returns the dimension of the ion&#39;s Hilbert space <code>ion.shape</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/ions.jl#L75-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.shape-Tuple{VibrationalMode}" href="#IonSim.shape-Tuple{VibrationalMode}"><code>IonSim.shape</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shape(mode::VibrationalMode)</code></pre><p>Returns <code>mode.shape</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/vibrationalmodes.jl#L83-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.sigma-Union{Tuple{T}, Tuple{Ion, T, T}} where T&lt;:Union{Int64, String, Tuple{String, Real}}" href="#IonSim.sigma-Union{Tuple{T}, Tuple{Ion, T, T}} where T&lt;:Union{Int64, String, Tuple{String, Real}}"><code>IonSim.sigma</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sigma(ion::Ion, ψ1::sublevel[, ψ2::sublevel])</code></pre><p>Returns <span>$|ψ1\rangle\langle ψ2|$</span>, where <span>$|ψ_i\rangle$</span> corresponds to the state returned by <code>ion[ψᵢ]</code>.</p><p>If ψ2 is not given, then <span>$|ψ1\rangle\langle ψ1|$</span> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/operators.jl#L175-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.speciesproperties-Tuple{Ion}" href="#IonSim.speciesproperties-Tuple{Ion}"><code>IonSim.speciesproperties</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">speciesproperties(ion::Ion)</code></pre><p>Returns the IonProperties struct of the ion species, which contains species-specific information including mass, energy levels, and transitions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/ions.jl#L54-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.sublevel-Tuple{Ion, String}" href="#IonSim.sublevel-Tuple{Ion, String}"><code>IonSim.sublevel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sublevel(I::Ion, alias::String)</code></pre><p>Returns the sublevel corresponding to the given alias <code>alias</code> of <code>I</code>. Inverse function of <code>sublevelalias</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/ions.jl#L258-L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.sublevelalias!-Tuple{Ion, Array{Tuple{Tuple{String, R}, String}, 1} where R&lt;:Real}" href="#IonSim.sublevelalias!-Tuple{Ion, Array{Tuple{Tuple{String, R}, String}, 1} where R&lt;:Real}"><code>IonSim.sublevelalias!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sublevelalias!(I::Ion, aliasassignments)</code></pre><p><code>aliasassignments</code> specifies which aliases should be assigned to which sublevels. There are two options to do this:</p><ul><li><code>aliasassignments</code> is a Vector of Tuples, with the first element of each being the sublevel (<code>sublevel::Tuple{String,Real}</code>) and the second being its assigned alias (<code>alias::String</code>)</li><li><code>aliasassignments</code> is a Dict with the format <code>alias::String =&gt; sublevel::Tuple{String,Real}</code></li></ul><p>Calls <code>sublevelalias!(I, sublevel, alias)</code> for each pair <code>sublevel, alias</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/ions.jl#L155-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.sublevelalias!-Tuple{Ion, Tuple{String, Real}, String}" href="#IonSim.sublevelalias!-Tuple{Ion, Tuple{String, Real}, String}"><code>IonSim.sublevelalias!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sublevelalias!(I::Ion, sublevel::Tuple{String,Real}, alias::String)</code></pre><p>Assigns an alias <code>alias</code> to <code>sublevel</code> of <code>I</code>. This then allows one to pass <code>alias</code> in place of <code>sublevel</code> (for <code>I</code> only) into any function which accepts a sublevel as an argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/ions.jl#L145-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.sublevelalias-Tuple{Ion, Tuple{String, Real}}" href="#IonSim.sublevelalias-Tuple{Ion, Tuple{String, Real}}"><code>IonSim.sublevelalias</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sublevelalias(I::Ion, sublevel::Tuple{String,Real})</code></pre><p>Returns the alias assined to <code>sublevel</code> of <code>I</code>. If no alias is assigned, returns <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/ions.jl#L240-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.sublevelaliases-Tuple{Ion}" href="#IonSim.sublevelaliases-Tuple{Ion}"><code>IonSim.sublevelaliases</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sublevelaliases(ion::Ion)</code></pre><p>Returns a <code>Dict</code> specifying all aliases assigned to sublevels of <code>ion</code>, in the format <code>alias =&gt; sublevel</code>, <code>ion.sublevelalias</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/ions.jl#L68-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.sublevels-Tuple{Ion}" href="#IonSim.sublevels-Tuple{Ion}"><code>IonSim.sublevels</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sublevels(ion::Ion)</code></pre><p>Returns the energy sublevels in the Hilbert space of <code>ion</code>, <code>ion.sublevels</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/ions.jl#L62-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.subleveltransitions-Tuple{Ion}" href="#IonSim.subleveltransitions-Tuple{Ion}"><code>IonSim.subleveltransitions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subleveltransitions(I::Ion)</code></pre><p>Returns all allowed transitions between sublevels of <code>I</code> as a vector of <code>Tuple{S,S}</code> where  <code>S=Tuple{String,Real}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/ions.jl#L486-L491">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.transitionfrequency-Tuple{Ion, Tuple, Chamber}" href="#IonSim.transitionfrequency-Tuple{Ion, Tuple, Chamber}"><code>IonSim.transitionfrequency</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transitionfrequency(ion, transition::Tuple, chamber::Chamber; ignore_manualshift=false)</code></pre><p>Returns The frequency of the transition <code>transition</code> including the Zeeman shift experienced by <code>ion</code> given its position in <code>T</code>. <code>ion</code> may be either an Ion or an Int indicating the desired ion&#39;s index within <code>chamber</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/chambers.jl#L576-L580">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.transitionfrequency-Tuple{Ion, Tuple}" href="#IonSim.transitionfrequency-Tuple{Ion, Tuple}"><code>IonSim.transitionfrequency</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transitionfrequency(I::Ion, transition::Tuple; B=0, ignore_manualshift=false)</code></pre><p><code>transition</code> is a Tuple of two sublevels or levels.</p><p>Computes the absolute values of the difference in energies between <code>transition[1]</code> and <code>transition[2]</code>.</p><p>If between sublevels, then the Zeeman shift may be included by setting the value of the magnetic field <code>B</code>, and manual shifts may be omitted by setting <code>ignore_manualshift=true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/ions.jl#L445-L452">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.transitionmultipole-Tuple{Ion, Tuple{String, String}}" href="#IonSim.transitionmultipole-Tuple{Ion, Tuple{String, String}}"><code>IonSim.transitionmultipole</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transitionmultipole(I::Ion, leveltransition::Tuple)</code></pre><p>Returns the transition multiple (<code>&#39;E1&#39;</code>, <code>&#39;E2&#39;</code>, etc.) corresponding to the transition <code>leveltransition[1] -&gt; leveltransition[2]</code>. The first level must be the lower level and the second must be the upper level.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/ions.jl#L525-L528">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.transitionwavelength-Tuple{Ion, Tuple, Chamber}" href="#IonSim.transitionwavelength-Tuple{Ion, Tuple, Chamber}"><code>IonSim.transitionwavelength</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transitionwavelength(ion, transition::Tuple, chamber::Chamber; ignore_manualshift=false)</code></pre><p>Returns The wavelength of the transition <code>transition</code> including the Zeeman shift experienced by <code>ion</code> given its position in <code>T</code>. <code>ion</code> may be either an Ion or an Int indicating the desired ion&#39;s index within <code>chamber</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/chambers.jl#L604-L608">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.transitionwavelength-Tuple{Ion, Tuple}" href="#IonSim.transitionwavelength-Tuple{Ion, Tuple}"><code>IonSim.transitionwavelength</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transitionwavelength(I::Ion, transition::Tuple; B=0, ignore_manualshift=false)</code></pre><p>Returns the wavelength corresponding to <code>transitionfrequency(I::Ion, transition::Tuple; B=0, ignore_manualshift=false)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/ions.jl#L461-L464">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.visualize-Tuple{LinearChain, Any, Any}" href="#IonSim.visualize-Tuple{LinearChain, Any, Any}"><code>IonSim.visualize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">visualize(lc::LinearChain, axis::String, modes::Vector{&lt;:Int}, format=&quot;bars&quot;)</code></pre><p>Visualize the normal mode structure of a <code>lc</code> as a Plots.jl plot. <code>axis</code> can either be one of &quot;x&quot;, &quot;y&quot;, &quot;z&quot; or a NamedTuple{(:x,:y,:z)}. <code>modes</code> is a vector of indices  selecting which modes should be included in the plot. Slicing is supported. <code>format</code> can be  either &quot;bars&quot; or &quot;circles.&quot;</p><p>Note that the indexing refers to the full normal mode description and not the subset  <code>selectedmodes(lc)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/iontraps.jl#L714-L724">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.visualize-Tuple{Tuple{Float64, Vector{Float64}}, NamedTuple{(:x, :y, :z), T} where T&lt;:Tuple}" href="#IonSim.visualize-Tuple{Tuple{Float64, Vector{Float64}}, NamedTuple{(:x, :y, :z), T} where T&lt;:Tuple}"><code>IonSim.visualize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">visualize(
    vm::Tuple{Float64, Vector{Float64}}, axis::NamedTuple{(:x, :y, :z)}; format=&quot;bars&quot;
)</code></pre><p>Same thing but input a normal mode description as a tuple with first element the eigenfrequency and second the eigenvector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/iontraps.jl#L923-L930">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.visualize-Tuple{VibrationalMode}" href="#IonSim.visualize-Tuple{VibrationalMode}"><code>IonSim.visualize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">visualize(vm::VibrationalMode; format=&quot;bars&quot;)</code></pre><p>Visualize the normal mode structure of a <code>vm</code> as a Plots.jl plot. <code>format</code> can be either <code>bar</code> or <code>ions</code>. <code>format</code> can be either &quot;bars&quot; or &quot;circles.&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/iontraps.jl#L857-L862">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.wavelength!-Tuple{Laser, Real}" href="#IonSim.wavelength!-Tuple{Laser, Real}"><code>IonSim.wavelength!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wavelength!(laser::Laser, λ::Real)</code></pre><p>Sets the wavelength of <code>laser</code> to <code>λ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/lasers.jl#L127-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.wavelength-Tuple{Laser}" href="#IonSim.wavelength-Tuple{Laser}"><code>IonSim.wavelength</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wavelength(laser::Laser)::Real</code></pre><p>Returns the laser&#39;s wavelength <code>laser.λ</code> (in m)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/lasers.jl#L80-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.wavelength_from_transition!-Tuple{Laser, Ion, Tuple, Chamber}" href="#IonSim.wavelength_from_transition!-Tuple{Laser, Ion, Tuple, Chamber}"><code>IonSim.wavelength_from_transition!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wavelength_from_transition!(laser::Laser, ion, transition::Tuple, chamber::Chamber)</code></pre><p>Sets the wavelength of <code>laser</code> to the transition wavelength of <code>transition</code> in the ion <code>ion</code>, at the magnetic field seen by <code>ion</code> in <code>chamber</code>. <code>ion</code> may be either an Ion or an Int indicating the desired ion&#39;s index within <code>chamber</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/chambers.jl#L643-L648">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.wavelength_from_transition!-Tuple{Laser, Ion, Tuple, Real}" href="#IonSim.wavelength_from_transition!-Tuple{Laser, Ion, Tuple, Real}"><code>IonSim.wavelength_from_transition!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wavelength_from_transition!(laser::Laser, ion::Ion, transition::Tuple, B::Real)</code></pre><p>Sets the wavelength of <code>laser</code> to the transition wavelength of <code>transition</code> in the ion <code>ion</code>, at a magnetic field value given by <code>B</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/chambers.jl#L632-L636">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.wavevector!-Tuple{Laser, NamedTuple{(:x, :y, :z), T} where T&lt;:Tuple}" href="#IonSim.wavevector!-Tuple{Laser, NamedTuple{(:x, :y, :z), T} where T&lt;:Tuple}"><code>IonSim.wavevector!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wavevector!(laser::Laser, k::ReNamedTuple{(:x, :y, :z)})</code></pre><p>Sets the wavevector of <code>laser</code> to <code>k</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/lasers.jl#L167-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.wavevector-Tuple{Laser}" href="#IonSim.wavevector-Tuple{Laser}"><code>IonSim.wavevector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wavevector(laser::Laser)::NamedTuple{(:x, :y, :z)}</code></pre><p>Returns the laser&#39;s wavevector unit vector <code>laser.k</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/lasers.jl#L104-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.xmodes-Tuple{Chamber}" href="#IonSim.xmodes-Tuple{Chamber}"><code>IonSim.xmodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">xmodes(T::Chamber)</code></pre><p>Returns an array of all of the selected <code>VibrationalModes</code> in the x-direction in the <code>Chamber</code>&#39;s <code>IonConfiguration</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/chambers.jl#L281-L284">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.xmodes-Tuple{LinearChain}" href="#IonSim.xmodes-Tuple{LinearChain}"><code>IonSim.xmodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">xmodes(lc::LinearChain)</code></pre><p>Returns an array of all of the selected <code>VibrationalModes</code> in the x-direction in the  <code>LinearChain</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/iontraps.jl#L609-L613">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.ymodes-Tuple{Chamber}" href="#IonSim.ymodes-Tuple{Chamber}"><code>IonSim.ymodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ymodes(T::Chamber)</code></pre><p>Returns an array of all of the selected <code>VibrationalModes</code> in the y-direction in the <code>Chamber</code>&#39;s <code>IonConfiguration</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/chambers.jl#L286-L289">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.ymodes-Tuple{LinearChain}" href="#IonSim.ymodes-Tuple{LinearChain}"><code>IonSim.ymodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ymodes(lc::LinearChain)</code></pre><p>Returns an array of all of the selected <code>VibrationalModes</code> in the y-direction in the  <code>LinearChain</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/iontraps.jl#L616-L620">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.zeemanshift-Tuple{Ion, Tuple{String, Real}, Real}" href="#IonSim.zeemanshift-Tuple{Ion, Tuple{String, Real}, Real}"><code>IonSim.zeemanshift</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zeemanshift(I::Ion, sublevel, B::Real)</code></pre><p>Returns the Zeeman shift at a magnetic field of <code>B</code> of <code>sublevel</code> of <code>I</code>. If <code>sublevel</code> has a custom g-factor defined, then this is used. Otherwise, <code>landegf</code> is used  to compute the Landé g-factor. Zeeman shift calculated as <span>$ΔE = (μ_B/ħ) ⋅ g_f ⋅ B ⋅ m / 2π$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/ions.jl#L383-L389">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.zeemanshift-Tuple{Ion, Union{String, Tuple{String, Real}}, Chamber}" href="#IonSim.zeemanshift-Tuple{Ion, Union{String, Tuple{String, Real}}, Chamber}"><code>IonSim.zeemanshift</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zeemanshift(I, sublevel, T::Chamber)</code></pre><p>Calls <code>zeemanshift(I::Ion, sublevel, B::Real)</code> with <code>B</code> evaluated for ion <code>I</code> in <code>T</code>. <code>I</code> may be either an Ion or an Int indicating the desired ion&#39;s index within <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/chambers.jl#L692-L696">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.zeromanualshift!-Tuple{Ion}" href="#IonSim.zeromanualshift!-Tuple{Ion}"><code>IonSim.zeromanualshift!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zeromanualshift!(I::Ion)</code></pre><p>Sets the manual shift of all sublevels of <code>I</code> to zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/ions.jl#L219-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.zmodes-Tuple{Chamber}" href="#IonSim.zmodes-Tuple{Chamber}"><code>IonSim.zmodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zmodes(T::Chamber)</code></pre><p>Returns an array of all of the selected <code>VibrationalModes</code> in the z-direction in the <code>Chamber</code>&#39;s <code>IonConfiguration</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/chambers.jl#L291-L294">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.zmodes-Tuple{LinearChain}" href="#IonSim.zmodes-Tuple{LinearChain}"><code>IonSim.zmodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zmodes(lc::LinearChain)</code></pre><p>Returns an array of all of the selected <code>VibrationalModes</code> in the z-direction in the  <code>LinearChain</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/iontraps.jl#L623-L627">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.coherentthermalstate-Tuple{VibrationalMode, Real, Number}" href="#QuantumOpticsBase.coherentthermalstate-Tuple{VibrationalMode, Real, Number}"><code>QuantumOpticsBase.coherentthermalstate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">coherentthermalstate(v::VibrationalMode, n̄::Real, α::Number; method=&quot;truncated)</code></pre><p>Returns a displaced thermal state for <code>v</code>, which is created by applying a displacement operation to a thermal state. The mean occupation of the thermal state is <code>n̄</code> and <code>α</code> is the complex amplitude of the displacement.</p><p><code>method</code> can be either <code>&quot;truncated&quot;</code> or <code>&quot;analytic&quot;</code> and this argument determines how the displacement operator is computed (see: <a href="api.html#QuantumOpticsBase.displace-Tuple{VibrationalMode, Number}"><code>displace</code></a>) .</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/operators.jl#L114-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.displace-Tuple{VibrationalMode, Number}" href="#QuantumOpticsBase.displace-Tuple{VibrationalMode, Number}"><code>QuantumOpticsBase.displace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">displace(v::VibrationalMode, α::Number; method=&quot;truncated&quot;)</code></pre><p>Returns the displacement operator <span>$D(α)$</span> corresponding to <code>v</code>.</p><p>If <code>method=&quot;truncated&quot;</code> (default), the matrix elements are computed according to <span>$D(α) = exp[αa^† - α^*a]$</span> where <span>$a$</span> and <span>$a^†$</span> live in a truncated Hilbert space of dimension <code>modecutoff(v)+1</code>. Otherwise if <code>method=&quot;analytic&quot;</code>, the matrix elements are computed assuming an infinite-dimension Hilbert space. In general, this option will not return a unitary operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/operators.jl#L39-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.fockstate-Tuple{VibrationalMode, Int64}" href="#QuantumOpticsBase.fockstate-Tuple{VibrationalMode, Int64}"><code>QuantumOpticsBase.fockstate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fockstate(v::VibrationalMode, N::Int)</code></pre><p>Returns the fockstate <span>$|N⟩$</span> on <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/operators.jl#L134-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.thermalstate-Tuple{VibrationalMode, Real}" href="#QuantumOpticsBase.thermalstate-Tuple{VibrationalMode, Real}"><code>QuantumOpticsBase.thermalstate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">thermalstate(v::VibrationalMode, n̄::Real; method=&quot;truncated&quot;)</code></pre><p>Returns a thermal density matrix with <span>$⟨a^†a⟩ ≈ n̄$</span>. Note: approximate because we are dealing with a finite dimensional Hilbert space that must be normalized.</p><p><code>method</code> can be set to either <code>&quot;truncated&quot;</code> (default) or <code>&quot;analytic&quot;</code>. In the former case, the thermal density matrix is generated according to the formula: <span>$ρ_{th} = exp(-νa^†a/T) / Tr [exp(-νa^†a/T)]$</span>. In the later case, the analytic formula, assuming an infinite-dimensional Hilbert space, is used: <span>$[ρ_{th}]_{ij} = δ_{ij} \frac{nⁱ}{(n+1)^{i+1}}.$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/operators.jl#L71-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.analytical.molmersorensen2ion-Tuple{Any, Real, Real, Real, Real, Real}" href="#IonSim.analytical.molmersorensen2ion-Tuple{Any, Real, Real, Real, Real, Real}"><code>IonSim.analytical.molmersorensen2ion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">molmersorensen2ion(tspan, Ω::Real, ν::Real, δ::Real, η::Real, n̄::Real)</code></pre><p><a href="https://doi.org/10.1103/PhysRevA.62.022311">ref</a> &lt;br&gt; Assumes vibrational mode starts in a thermal state with: <span>$\langle a^\dagger a\rangle = n̄$</span>  and ions start in doubly ground state. Returns <code>(ρgg, ρee)</code>, the population in the doubly  ground and doubly excited state, respectively. <span>$[Ω], [ν], [δ] = Hz$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/analyticfunctions.jl#L4-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.analytical.rabiflop-Tuple{Any, Real, Real, Real}" href="#IonSim.analytical.rabiflop-Tuple{Any, Real, Real, Real}"><code>IonSim.analytical.rabiflop</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rabiflop(tspan, Ω::Real, η::Real, n̄::Real; s::Int=0) &lt;br&gt;</code></pre><p>Single ion rabi flop. Returns: <span>$\sum_{n=0}^∞ p_n sin^2(\Omega_n t)$</span> &lt;br&gt; with <span>$\Omega_n = Ωe^{-η^2/2}η^s\sqrt{\frac{n!}{(n+s)!}}L_{n}^{s}(η^2)$</span> &lt;br&gt; where <span>$s$</span> is the order of the (blue) sideband that we are driving and <span>$L_{n}^{s}$</span> is the associated Laguerre polynomial. <a href="https://doi.org/10.1103/RevModPhys.75.281">ref</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/analyticfunctions.jl#L40-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.PhysicalConstants.c" href="#IonSim.PhysicalConstants.c"><code>IonSim.PhysicalConstants.c</code></a> — <span class="docstring-category">Constant</span></header><section><div><p><code>c</code> = 2.99792458e8 m/s &lt;br&gt; (speed of light in vacuum)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/constants.jl#L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.PhysicalConstants.c_rank1" href="#IonSim.PhysicalConstants.c_rank1"><code>IonSim.PhysicalConstants.c_rank1</code></a> — <span class="docstring-category">Constant</span></header><section><div><p><code>c_rank1</code>: Matrix of spherical basis vectors (defined in e.g. Quantum dynamics of cold trapped ions with application to quantum computation, Appl. Phys. B 66, 181-190 (1998).</p><p>Useful for converting between coordinates of rank-1 spherical tensors and Cartesian coordinates</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/constants.jl#L42-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.PhysicalConstants.c_rank2" href="#IonSim.PhysicalConstants.c_rank2"><code>IonSim.PhysicalConstants.c_rank2</code></a> — <span class="docstring-category">Constant</span></header><section><div><p><code>c_rank2</code>: Matrix of spherical basis rank-2 tensors (defined in e.g. Quantum dynamics of cold trapped ions with application to quantum computation, Appl. Phys. B 66, 181-190 (1998).</p><p>Useful for converting between coordinates of rank-2 spherical tensors and Cartesian coordinates</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/constants.jl#L51-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.PhysicalConstants.e" href="#IonSim.PhysicalConstants.e"><code>IonSim.PhysicalConstants.e</code></a> — <span class="docstring-category">Constant</span></header><section><div><p><code>e</code> = 1.60217662e-19 C &lt;br&gt; (charge of electron)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/constants.jl#L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.PhysicalConstants.eye3" href="#IonSim.PhysicalConstants.eye3"><code>IonSim.PhysicalConstants.eye3</code></a> — <span class="docstring-category">Constant</span></header><section><div><p><code>eye3</code>: Three-dimensional identity matrix</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/constants.jl#L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.PhysicalConstants.kB" href="#IonSim.PhysicalConstants.kB"><code>IonSim.PhysicalConstants.kB</code></a> — <span class="docstring-category">Constant</span></header><section><div><p><code>kB</code> = 1.38064852e-23 <span>$m^2kg/(s^2K)$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/constants.jl#L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.PhysicalConstants.ħ" href="#IonSim.PhysicalConstants.ħ"><code>IonSim.PhysicalConstants.ħ</code></a> — <span class="docstring-category">Constant</span></header><section><div><p><code>ħ</code> = 1.0545718e-34 m²kg/s &lt;br&gt; (Planck&#39;s constant / 2π)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/constants.jl#L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.PhysicalConstants.α" href="#IonSim.PhysicalConstants.α"><code>IonSim.PhysicalConstants.α</code></a> — <span class="docstring-category">Constant</span></header><section><div><p><code>α</code> = e²/4πϵ₀ħc``</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/constants.jl#L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.PhysicalConstants.μB" href="#IonSim.PhysicalConstants.μB"><code>IonSim.PhysicalConstants.μB</code></a> — <span class="docstring-category">Constant</span></header><section><div><p><code>μB</code> = 9.27400994e-24 J⋅T⁻¹ &lt;br&gt; (Bohr Magneton)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/constants.jl#L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IonSim.PhysicalConstants.ϵ₀" href="#IonSim.PhysicalConstants.ϵ₀"><code>IonSim.PhysicalConstants.ϵ₀</code></a> — <span class="docstring-category">Constant</span></header><section><div><p><code>ϵ₀</code> = 8.85418782e-12 <span>$(s^4A^2) / (m^3 kg)$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HaeffnerLab/IonSim.jl/blob/3bbdce9483ef2a9d960812d99dac2fd1d85fc60f/src/constants.jl#L28">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="examples.html">« Examples</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Monday 10 April 2023 23:02">Monday 10 April 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
